<?xml version="1.0" encoding="UTF-8"?>
<root>
    <doclet-version-NOT-library-version>1.02</doclet-version-NOT-library-version>
    <class>
        <name>jpct.ae.wrapper.JWorld</name>
        <shortname>JpctWorld</shortname>
        <objectwrapper>com.threed.jpct.World</objectwrapper>
        <owner>process</owner>
        <method>
            <name>checkCameraCollisionSpherical</name>
            <comment>Moves the camera moveSpeed units from its current position and regarding its current orientation 
 into "mode" direction, if this is possible. Uses a sphere-polygon collision detection. This method 
 can be used in CAMERA_DONT_MOVE-mode too, where the camera will only be adjusted automatically if 
 anything that is a collider has moved in its way.
 -
 mode - the direction (relative to its orientation)
 radius - the radius of the sphere. A collision will only be detected within this radius.
 moveSpeed - the number of units the camera should move
 slideMode - indicates if the camera should slide or just stand still in case of collision</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>radius</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>moveSpeed</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>slideMode</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>FOGGING_DISABLED</name>
            <comment>No linear distance fogging will be used (default).</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>checkCollision</name>
            <comment>Checks if a collision between "something" and an object would take place if this 
 "something" would move step units from its position into a given direction. The 
 method can be used to implement various kinds of collision detection/response and 
 uses a ray-polygon collision detection. All objects should have been set to an 
 appropiate collision mode.
 -
 org - the position vector of "something"
 dr - the direction vector of "something" (a unit vector, if not it'll be made one)
 step - the length of the casted ray (a collision will only be detected of it takes
 place within this range)</comment>
            <returntype>int</returntype>
            <parameter>
                <name>org</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>dr</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>step</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>addPolyline</name>
            <comment>Adds a new Polyline to the world. A Polyline is a line strip with a color that will be drawn 
 into the scene after all other objects has been drawn. A Polyline's coordinates are to be given 
 in world space. You can add multiple Polylines to a world.
 -
 line - the Polyline</comment>
            <returntype>void</returntype>
            <parameter>
                <name>line</name>
                <type>com.threed.jpct.Polyline</type>
            </parameter>
        </method>
        <method>
            <name>checkCameraCollision3</name>
            <comment>Moves the camera moveSpeed units from its current position and regarding its current 
 orientation into "mode" direction, if this is possible. Uses a ray-polygon collision
 detection.
 -
 mode - the direction (relative to its orientation)
 moveSpeed - the number of units the camera should move
 distance - the maximum distance the position vector can have from the polygon before a 
 collision is detected.
 slideMode - indicates if the camera should slide or just stand still in case of collision</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>moveSpeed</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>distance</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>slideMode</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>checkCameraCollision4</name>
            <comment>Moves the camera moveSpeed units from its current position into an arbitrary direction, 
 if this is possible. Uses a ray-polygon collision detection.
 -
 direction - the direction (should be a normalized vector (i.e. a length of 1))
 moveSpeed - the number of units the camera should move
 distance - the maximum distance the position vector can have from the polygon before a collision is detected.
 slideMode - indicates if the camera should slide or just stand still in case of collision</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>direction</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>moveSpeed</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>distance</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>slideMode</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>checkCameraCollision</name>
            <comment>Moves the camera moveSpeed units from its current position and regarding its current 
 orientation into "mode" direction, if this is possible. If not, the camera will "slide" 
 in the remaining directions. Uses a ray-polygon collision detection.
 -
 mode - the direction (relative to its orientation)
 moveSpeed - the number of units the camera should move</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>moveSpeed</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>checkCameraCollision2</name>
            <comment>Moves the camera moveSpeed units from its current position and regarding its current 
 orientation into "mode" direction, if this is possible. Uses a ray-polygon collision 
 detection.
 -
 mode - the direction (relative to its orientation)
 moveSpeed - the number of units the camera should move
 slideMode - indicates if the camera should slide or just stand still in case of collision</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>moveSpeed</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>slideMode</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>draw</name>
            <comment>Draws the current scene that has been generated geometry wise by renderScene(). Usually, 
 renderScene() and draw() are used one right after the other (with draw being the last).
 -
 buffer - the framebuffer that should be used for rendering</comment>
            <returntype>void</returntype>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
        </method>
        <method>
            <name>checkCameraCollisionEllipsoid</name>
            <comment>Moves the camera moveSpeed units from its current position into an arbitrary direction, if this is 
 possible. Uses a (swept)ellipsoid-polygon collision detection. This method will always use sliding.
 -
 mode - the direction (relative to its orientation)
 ellipsoid - the radius of the epplisoid in x,y and z direction
 moveSpeed - the number of units the camera should move
 recursionDepth - the max. recursion depth of the collision detection. A higher value will improve 
 the accuracy of the collision detection but reduce performance. Reasonable values lie between 1 and 5.</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>ellipsoid</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>moveSpeed</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>recursionDepth</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>removeAllLights</name>
            <comment>Removes all lights from the world. 
 The scene will be lit by ambient lighting only after calling this method.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>setFogParameters2</name>
            <comment>Sets the parameters for the linear distance fog (if enabled).
 -
 start - where the fog actually starts.
 distance - the distance in camera-space coordinates at which the fog reaches its 
 maximum density (150 is default, 1 is minimum)
 red - the red component of the fog ([0..255], 0 is default)
 green - the green component of the fog ([0..255], 0 is default)
 blue - the blue component of the fog ([0..255], 0 is default)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>start</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>distance</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>red</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>green</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>blue</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>calcMinDistanceAndObject3D</name>
            <comment>Returns the minimal distance to some polygon of the world's objects (have to be colliders) 
 from a particular position vector looking into a specific direction. It only takes polygons 
 into consideration that have at least one vertex that is closer than ignoreIfLarger units to 
 the position vector and whose bounding box/octree-node is closer than that value too. In 
 addition to calcMinDistance(), this method returns the object to which the polygon belongs.
 -
 orig - a SimpleVector containing the x,y,z-coordinates of the position vector
 dir - a SimpleVector array containing the x,y,z-coordinates of the direction vector (a unit vector)
 ignoreIfLarger - only polygons/bounding boxes/octree-nodes within this range will be taken into 
 account</comment>
            <returntype>java.lang.Object[]</returntype>
            <parameter>
                <name>orig</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>dir</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>ignoreIfLarger</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>renderScene</name>
            <comment>Transforms and lights all the polygons. This method does everything required to start drawing the 
 current scene. It just doesn't scanconvert the results. This is done by the draw()-method. This 
 method has to be called at least once before blitting into the FrameBuffer will work correctly. If 
 you are not abusing jPCT as a pure 2D blitting engine, then this shouldn't be a problem anyway.
 -
 buffer - the framebuffer that should be used for rendering</comment>
            <returntype>void</returntype>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
        </method>
        <method>
            <name>compileAllObjects</name>
            <comment>Compiles all objects in the world for better gpu processing. You don't have to call this method, 
 because it will be done in demand anyway. However, it may be better to compile all objects before 
 starting the actual render loop to avoid hick-ups when auto-compiling while drawing things. Already 
 compiled objects won't be affected.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>calcMinDistance</name>
            <comment>Returns the minimal distance to some polygon of the world's objects (have to be colliders) from 
 a particular position vector looking into a specific direction. It only takes polygons into 
 consideration that have at least one vertex that is closer than ignoreIfLarger units to the 
 position vector and whose bounding box/octree-node is closer than that value too.
 -
 orig - a SimpleVector containing the x,y,z-coordinates of the position vector
 dir - a SimpleVector array containing the x,y,z-coordinates of the direction vector (a unit vector)
 ignoreIfLarger - only polygons/bounding boxes/octree-nodes within this range will be taken into 
 account</comment>
            <returntype>float</returntype>
            <parameter>
                <name>orig</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>dir</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>ignoreIfLarger</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>removeAll</name>
            <comment>Removes all lights and objects from the world.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>getObject</name>
            <comment>Returns the object with the given ID from the World's object collection.
 -
 id - the ID of the object</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>id</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>removeObject2</name>
            <comment>Removes the given object from the World's object collection. This method doesn't check for 
 child/parent objects of the removed object, which will remain intact.
 -
 obj - the object to remove</comment>
            <returntype>void</returntype>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>Initialize</name>
            <comment>Initialize the world</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>removePolyline</name>
            <comment>Removes a Polyline from a world.
 -
 line - the line</comment>
            <returntype>void</returntype>
            <parameter>
                <name>line</name>
                <type>com.threed.jpct.Polyline</type>
            </parameter>
        </method>
        <method>
            <name>addObjects</name>
            <comment>Adds all objects from the given array to the world. This can be useful, if one wants to add 
 a Object3Ds loaded by the 3DS/OBJ loaders to a world at once.
 -
 objs - the objects</comment>
            <returntype>void</returntype>
            <parameter>
                <name>objs</name>
                <type>com.threed.jpct.Object3D[]</type>
            </parameter>
        </method>
        <method>
            <name>dispose</name>
            <comment>Disposes the world. This method should be called before the world goes out of scope. 
 This frees some resources that may otherwise be locked.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>setAmbientLight</name>
            <comment>Sets the light intensity for the ambient light source. Setting this is negative values will 
 darken the whole scene while positive ones will light up everything.
 -
 r - the red component (100 is default)
 g - the red component (100 is default)
 b - the red component (100 is default)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>r</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>g</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>b</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>removeAllObjects</name>
            <comment>Removes all but the internal objects from the world.
 The world is empty after calling this method.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>drawWireframe</name>
            <comment>Draws the current scene as a single-colored wireframe. This is done using the same buffer draw() 
 draws into. drawWireframe() can be called instead of draw() to get the wireframe only as well as 
 right after draw() to combine the two renderings for some special effects. Calling drawWireframe() 
 before draw() doesn't make much sense. jPCT's wireframe mode is not as optimized as the texturemapped 
 mode is (yet) but it should be "fast enough".
 -
 buffer - the framebuffer that should be used for rendering
 color - the wireframe's color</comment>
            <returntype>void</returntype>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>color</name>
                <type>com.threed.jpct.RGBColor</type>
            </parameter>
        </method>
        <method>
            <name>setClippingPlanes</name>
            <comment>If set, this overrides the settings in Config for the near and the far clipping plane
 for this world. If you don't touch this method, the settings in Config will be taken 
 instead.
 -
 near - the near plane
 far - the far plane</comment>
            <returntype>void</returntype>
            <parameter>
                <name>near</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>far</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>buildAllObjects</name>
            <comment>Calls build() for every object in the world.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>setFogParameters</name>
            <comment>Sets the parameters for the linear distance fog (if enabled).
 -
 distance - the distance in camera-space coordinates at which the fog reaches its 
 maximum density (150 is default, 1 is minimum)
 red - the red component of the fog ([0..255], 0 is default)
 green - the green component of the fog ([0..255], 0 is default)
 blue - the blue component of the fog ([0..255], 0 is default)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>distance</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>red</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>green</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>blue</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>FOGGING_ENABLED</name>
            <comment>Linear distance fogging will be used.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>getObjectByName</name>
            <comment>Returns the object named "name" from the World's object collection. This is an alternative 
 albeit slower way to retrieve objects from the World. A better idea would be not ot lose 
 them anyway...:-)
 -
 name - the name of the object</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>checkCollisionSpherical</name>
            <comment>Checks if a collision between "something" and an object would take place if this 
 "something" would move step units from its position into a given direction. The 
 method can be used to implement various kinds of collision detection/response and 
 uses a sphere-polygon collision detection. All objects should have been set to an 
 appropiate collision mode.
 -
 org - the position vector of "something"
 translation - that should be applied to "something" (Note that this method just 
 checks this translation...it doesn't apply it)
 radius - the radius of the sphere (a collision will only be detected of it takes 
 place within this radius)</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>org</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>translation</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>radius</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>removeObject</name>
            <comment>Removes the object with the specified ID from the World's object collection. This method 
 doesn't check for child/parent objects of the removed object, which will remain intact.
 -
 id - the ID of the object to remove</comment>
            <returntype>void</returntype>
            <parameter>
                <name>id</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>checkCameraCollisionSpherical2</name>
            <comment>Moves the camera moveSpeed units from its current position into an arbitrary direction, if this is 
 possible. Uses a sphere-polygon collision detection.
 -
 direction - the direction (should be a normalized vector (i.e. a length of 1))
 radius - the radius of the sphere. A collision will only be detected within this radius.
 moveSpeed - the number of units the camera should move
 slideMode - indicates if the camera should slide or just stand still in case of collision</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>direction</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>radius</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>moveSpeed</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>slideMode</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>newCamera</name>
            <comment>Resets the camera to origin looking along the z-axis. This is the position and 
 orientation the camera has after creating a new "world".</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>checkCollisionEllipsoid</name>
            <comment>Checks if a collision between "something" and an object would take place if this 
 "something" would move step units from its position into a given direction. The method 
 can be used to implement various kinds of collision detection/response and uses a (swept)
 ellipsoid-polygon collision detection. All objects should have been set to an appropiate 
 collision mode.
 -
 org - the position vector of "something"
 translation - that should be applied to "something" (Note that this method just checks 
 this translation...it doesn't apply it)
 ellipsoid - the radius of the epplisoid in x,y and z direction
 recursionDepth - the max. recursion depth of the collision detection. A higher value will 
 improve the accuracy of the collision detection but reduce performance. Reasonable values 
 lie between 1 and 5.</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>org</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>translation</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>ellipsoid</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>recursionDepth</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>checkCameraCollisionEllipsoid2</name>
            <comment>Moves the camera moveSpeed units from its current position into an arbitrary direction, if this is 
 possible. Uses a (swept)ellipsoid-polygon collision detection. This method will always use sliding.
 -
 direction - the direction (should be a normalized vector (i.e. a length of 1))
 ellipsoid - the radius of the epplisoid in x,y and z direction
 moveSpeed - the number of units the camera should move
 recursionDepth - the max. recursion depth of the collision detection. A higher value will improve 
 the accuracy of the collision detection but reduce performance. Reasonable values lie between 1 and 5.</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>direction</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>ellipsoid</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>moveSpeed</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>recursionDepth</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>addObject</name>
            <comment>Adds an object to the World's object collection. The object will be referenced in this 
 collection by its ID. The ID of the object in the collection is the same as the object's own
 ID. addObject() also returns this ID due to "historical reasons". So id=addObject(obj) is 
 basically the same as id=obj.getID(); addObject(obj); Note: Current implementation limits the 
 object-World bindings in a way that an object can only be added to one world at a time. This 
 method doesn't check if the object has been added multiple times. This may change later.
 -
 obj - the object to be added</comment>
            <returntype>int</returntype>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <property>
            <name>Fogging</name>
            <returntype>int</returntype>
            <parameter>
                <name>fog</name>
                <type>int</type>
            </parameter>
            <comment>Returns if fogging is being used or not.</comment>
        </property>
        <property>
            <name>DefaultThread</name>
            <returntype>java.lang.Thread</returntype>
            <parameter>
                <name>def</name>
                <type>java.lang.Thread</type>
            </parameter>
            <comment>Returns the default thread or null if none has been set.</comment>
        </property>
        <property>
            <name>ObjectsVisibility</name>
            <parameter>
                <name>visible</name>
                <type>boolean</type>
            </parameter>
            <comment>Sets the visibility for all objects that belong to a world.
 -
 visible - visible or not?</comment>
        </property>
        <property>
            <name>AmbientLight</name>
            <returntype>int[]</returntype>
            <comment>Returns the ambient light's intensities in an int[]-array in r,g,b order.</comment>
        </property>
        <property>
            <name>Camera</name>
            <returntype>com.threed.jpct.Camera</returntype>
            <comment>Gets the current camera.</comment>
        </property>
        <property>
            <name>CameraTo</name>
            <parameter>
                <name>cam</name>
                <type>com.threed.jpct.Camera</type>
            </parameter>
            <comment>Sets the camera to another one.
 cam - the camera to use</comment>
        </property>
        <property>
            <name>GlobalShader</name>
            <returntype>com.threed.jpct.GLSLShader</returntype>
            <parameter>
                <name>globalShader</name>
                <type>com.threed.jpct.GLSLShader</type>
            </parameter>
            <comment>Returns the global shader or null if none has been set.</comment>
        </property>
        <property>
            <name>Objects</name>
            <returntype>java.util.Enumeration</returntype>
            <comment>Returns an Enumeration of all user defined objects in this world.</comment>
        </property>
        <property>
            <name>FrameCounter</name>
            <returntype>long</returntype>
            <comment>Returns the number of frames rendered since startup.</comment>
        </property>
        <property>
            <name>Size</name>
            <returntype>int</returntype>
            <comment>Returns the number of user defined objects in this World.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JVirtualizer</name>
        <shortname>JpctVirtualizer</shortname>
        <objectwrapper>com.threed.jpct.Virtualizer</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>constructor to Initialize the Virtualizer</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>finalize</name>
            <comment>Overrides: finalize in class java.lang.Object</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Creates a new instance of the Virtualizer with an estimated maximum size.
 -
 sizeInMb - the maximum size. It might exceed this size, but not by a huge amount.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>sizeInMb</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>cleanUp</name>
            <comment>Cleans up the Virtualizer. This will delete virtualized (but not cached) files.</comment>
            <returntype>void</returntype>
        </method>
        <property>
            <name>Context</name>
            <parameter>
                <name>ctx</name>
                <type>android.content.Context</type>
            </parameter>
            <comment>Sets the context. Without it, the Virtualizer can't work.
 -
 ctx - the context</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JTextureManager</name>
        <shortname>JpctTextureManager</shortname>
        <objectwrapper>com.threed.jpct.TextureManager</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Initialize the TextureManager</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>TEXTURE_NOTFOUND</name>
            <comment>The id of a none-existent texture.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>getTextureByID</name>
            <comment>Returns the texture with the ID or null if no such texture can be found.
 -
 id - int the ID</comment>
            <returntype>com.threed.jpct.Texture</returntype>
            <parameter>
                <name>id</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>getTextureID</name>
            <comment>Returns the numerical ID of the texture. This value is used internally to access textures faster 
 than by using their names. Some methods use this ID instead of the unique name or the texture itself 
 for performance reasons.
 -
 name - the name of the texture</comment>
            <returntype>int</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>containsTexture</name>
            <comment>Checks if a texture has already been added to the texture-manager (or better: if a texture with 
 this name exists within the manager instance).
 -
 name - the name of the texture</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>virtualize</name>
            <comment>Virtualizes a textures if a Virtualizer has been set. This means that the texture might 
 (and most likely will) be swapped to disk instead of being kept in memory. This doesn't 
 affect the texture data uploaded to the GPU of course. Note that you can't use an 
 ITextureEffect on a virtualized texture.
 -
 tex - the Texture to virtualize. If it is virtual already, no actions will be taken.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>tex</name>
                <type>com.threed.jpct.Texture</type>
            </parameter>
        </method>
        <method>
            <name>getNameByID</name>
            <comment>Gets the name with which the texture with the given ID has been added to the manager.
 -
 id - the texture's ID</comment>
            <returntype>java.lang.String</returntype>
            <parameter>
                <name>id</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>removeAndUnload</name>
            <comment>Combines removal and unload of a texture. Everything mentioned in the single methods applies here too.
 -
 name - the texture's name
 from - the FrameBuffer</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>from</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
        </method>
        <method>
            <name>addTexture</name>
            <comment>Adds a texture with the given name to the manager. The name has to be unique, otherwise 
 no texture will be added. The added texture will be filled with a dummy texture and may 
 be replaced by another one later. This could be useful to render something without every 
 texture being loaded (for slow connections for example).
 -
 name - the (unique) name for this texture</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>compress</name>
            <comment>Compresses all texture known to the TextureManager so that they use less main memory. This doesn't 
 effect the memory used inside the gpu. Compressed textures require some more time to upload.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>removeTexture</name>
            <comment>Removes a texture from the manager. Because the manager doesn't know if a texture is still in use 
 by some object, you have to be sure that it isn't before calling this method. This method removes 
 the texture from the manager only. That doesn't mean, that it will be unloaded from video memory. 
 To ensure this, call unloadTexture() in addition or use removeAndUnload(). Please note that you 
 can't expect an object that uses this texture to get a new texture that you might add with the 
 same name after removing this one. If you want to replace textures on objects, use replaceTexture() 
 instead.
 -
 name - the name of the texture to be removed</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>unloadTexture</name>
            <comment>Unloads a texture from the contexts of the renderers of the given frame buffer. This isn't done 
 immediatly but in the next render pass for that buffer. You can try to unload any texture, it 
 doesn't have to belong to the manager (...any longer). If a texture hasn't been uploaded, it will 
 be ignored. If it's used after the unload, the renderer will upload it again.
 -
 from - the FrameBuffer
 texture - the texture to unload</comment>
            <returntype>void</returntype>
            <parameter>
                <name>from</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>texture</name>
                <type>com.threed.jpct.Texture</type>
            </parameter>
        </method>
        <method>
            <name>flush</name>
            <comment>Flushes the textures in the manager. In other words: The manager doesn't contain any textures after 
 calling flush().</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>getTexture</name>
            <comment>Returns the texture being named 'name'.
 -
 name - the name of the texture that should be retrieved</comment>
            <returntype>com.threed.jpct.Texture</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>replaceTexture</name>
            <comment>Replaces a texture with the given name with another one. It might be required to call 
 unloadTexture() before to ensure that the old texture has been unloaded from the GPU in case 
 it's no longer used somewhere else.
 -
 name - the (unique) name of the texture to replace
 tex - the new texture</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>tex</name>
                <type>com.threed.jpct.Texture</type>
            </parameter>
        </method>
        <method>
            <name>preWarm</name>
            <comment>Does some work that may otherwise happen during runtime and can cause hick-ups like uploading all 
 known textures if needed before the renderer is going to use them anyway. This only affects the 
 textures that the TextureManager currently knows. It has to be called within the render thread, 
 i.e. within onDraw() for example.
 -
 buffer - the current frame buffer.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
        </method>
        <method>
            <name>addTexture2</name>
            <comment>Adds a texture with the given name to the manager. The name has to be unique, otherwise no 
 texture will be added.
 -
 name - the (unique) name for this texture
 tex - the texture</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>tex</name>
                <type>com.threed.jpct.Texture</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>TextureCount</name>
            <returntype>int</returntype>
            <comment>Returns the number of textures the TextureManager holds.</comment>
        </property>
        <property>
            <name>MemoryUsage</name>
            <returntype>long</returntype>
            <comment>Returns the VM memory used to store the texture data. Doesn't take the GPU memory into account.</comment>
        </property>
        <property>
            <name>State</name>
            <returntype>java.util.List</returntype>
            <parameter>
                <name>dump</name>
                <type>java.util.List</type>
            </parameter>
            <comment>Dumps the current state of the TextureManager to a Vector. If you are serializing 
 this Vector, you may later setup the TextureManager at once with the deserialized 
 dump. If you are not using serialization, ignore this method.</comment>
        </property>
        <property>
            <name>DummyTexture</name>
            <returntype>com.threed.jpct.Texture</returntype>
            <parameter>
                <name>texture</name>
                <type>com.threed.jpct.Texture</type>
            </parameter>
            <comment>Returns the current dummy texture.</comment>
        </property>
        <property>
            <name>Virtualizer</name>
            <returntype>com.threed.jpct.Virtualizer</returntype>
            <parameter>
                <name>textureVirtualizer</name>
                <type>com.threed.jpct.Virtualizer</type>
            </parameter>
            <comment>Returns the current Virtualizer. By default, none is set.</comment>
        </property>
        <property>
            <name>Names</name>
            <returntype>java.util.HashSet</returntype>
            <comment>Gets all the names of the textures that have been added to the manager.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JTextureInfo</name>
        <shortname>JpctTextureInfo</shortname>
        <objectwrapper>com.threed.jpct.TextureInfo</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Creates a new TextureInfo. This is a shortcut to the method above, 
 if the u/v-coordinates are not required.
 -
 texID - int the ID of the Texture as the TextureManager sees it.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>texID</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>set</name>
            <comment>Sets the values of an existing layer. This is a shortcut to the method above,
 if the u/v-coordinates are not required.
 -
 texID - int the ID of the Texture as the TextureManager sees it.
 stageCnt - int the stage
 mode - int the combination mode</comment>
            <returntype>void</returntype>
            <parameter>
                <name>texID</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>stageCnt</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>MODE_BLEND</name>
            <comment>Use blending for adding this texture layer.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>add</name>
            <comment>Adds another texture layer. This is a shortcut to the method above, 
 if the u/v-coordinates are not required.
 -
 texID - int the Texture's ID
 mode - int the combination mode</comment>
            <returntype>void</returntype>
            <parameter>
                <name>texID</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>MODE_MODULATE</name>
            <comment>Use multiplication of color values for adding this
 texture layer.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>add2</name>
            <comment>Adds another texture layer.
 -
 texID - int the ID of the Texture as the TextureManager sees it.
 u0 - float the u-coordinate for the first vertex
 v0 - float the v-coordinate for the first vertex
 u1 - float the u-coordinate for the second vertex
 v1 - float the v-coordinate for the second vertex
 u2 - float the u-coordinate for the third vertex
 v2 - float the v-coordinate for the third vertex
 mode - int the combination mode</comment>
            <returntype>void</returntype>
            <parameter>
                <name>texID</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>u0</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v0</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>u1</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v1</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>u2</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v2</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>MODE_REPLACE</name>
            <comment>For the sake of completeness. Every texture from a lower 
 stage is replaced by the texture in the stage that uses 
 this mode.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>MODE_ADD</name>
            <comment>Use addition for adding this texture layer.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>MAX_PHYSICAL_TEXTURE_STAGES</name>
            <comment>The maximum number of physical texture layers available. 
 If the hardware supports more, jPCT will simply ignore them.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Creates a new TextureInfo.
 -
 texID - int the ID of the Texture as the TextureManager sees it.
 u0 - float the u-coordinate for the first vertex
 v0 - float the v-coordinate for the first vertex
 u1 - float the u-coordinate for the second vertex
 v1 - float the v-coordinate for the second vertex
 u2 - float the u-coordinate for the third vertex
 v2 - float the v-coordinate for the third vertex</comment>
            <returntype>void</returntype>
            <parameter>
                <name>texID</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>u0</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v0</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>u1</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v1</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>u2</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v2</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>set2</name>
            <comment>Sets the values of an existing layer.
 -
 texID - int the ID of the Texture as the TextureManager sees it.
 stageCnt - int the stage
 u0 - float the u-coordinate for the first vertex
 v0 - float the v-coordinate for the first vertex
 u1 - float the u-coordinate for the second vertex
 v1 - float the v-coordinate for the second vertex
 u2 - float the u-coordinate for the third vertex
 v2 - float the v-coordinate for the third vertex
 mode - int the combination mode</comment>
            <returntype>void</returntype>
            <parameter>
                <name>texID</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>stageCnt</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>u0</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v0</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>u1</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v1</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>u2</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v2</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JTextureEffect</name>
        <shortname>JpctTextureEffect</shortname>
        <objectwrapper>jpct.ae.wrapper.TextureEffect</objectwrapper>
        <owner>process</owner>
        <event>TextureEffect(dest() As Int, src() As Int)</event>
        <method>
            <name>Initialize</name>
            <comment>Initialize the Texture Effect
 eventName - the name of the Texture Effect's event</comment>
            <returntype>void</returntype>
            <parameter>
                <name>ba</name>
                <type>anywheresoftware.b4a.BA</type>
            </parameter>
            <parameter>
                <name>eventName</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>containsAlpha</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JTexture</name>
        <shortname>JpctTexture</shortname>
        <objectwrapper>com.threed.jpct.Texture</objectwrapper>
        <owner>process</owner>
        <method>
            <name>enable4bpp</name>
            <comment>Makes jPCT converting this texture to use 4 bits per pixel/alpha (respectively 5/1 
 without a dedicated alpha channel) instead of 8, i.e. use 16 bit textures. Default is 
 false unless you call Texture.defaultTo4bpp(true);
 -
 doit - should we?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>doit</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>defaultTo4bpp</name>
            <comment>Static method to set the textures' default depth to 4bpp (respectively 5bpp without
 a dedicated alpha channel). This doesn't affect the Texture instances themselves but
 the data uploaded to the graphics card.
 -
 doit - should 4bpp be the default?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>doit</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>add</name>
            <comment>Adds a textures color (and alpha) information to this one.
 -
 ta - the texture whose color should be added
 weight - the weight of the second texture's data. May be even negative.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>ta</name>
                <type>com.threed.jpct.Texture</type>
            </parameter>
            <parameter>
                <name>weight</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>applyEffect</name>
            <comment>Applies the effect to the texture. Depending on the implementation of the effect,
 this can be slow.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>keepPixelData</name>
            <comment>Should a texture's pixels be kept even when the texture has been uploaded to the GPU? 
 Default is false.
 -
 keepData - should they?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>keepData</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>Initialize8</name>
            <comment>Creates a black texture with alpha in the given dimensions.
 -
 width - the width of the texture. Has to be a power of 2. If its not, 
 it will be adjusted accordingly.
 height - the height of the texture. Has to be a power of 2. If its not, 
 it will be adjusted accordingly.
 alpha - the alpha value (0..255)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>width</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>height</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>alpha</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>defaultToKeepPixels</name>
            <comment>Static method to set the textures' default behaviour for keeping the pixel data after 
 uploading to the gpu. Default is true.
 -
 doit - should we keep the pixles</comment>
            <returntype>void</returntype>
            <parameter>
                <name>doit</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>defaultToMipmapping</name>
            <comment>Static method to make all textures use mipmaps by default. Default setting is false.
 -
 doit - should mipmapping be the default?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>doit</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>Initialize9</name>
            <comment>Creates a colored texture with no alpha in the given dimensions.
 -
 width - the width of the texture. Has to be a power of 2.
 height - the height of the texture. Has to be a power of 2.
 col - the color. Can be null for render targets.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>width</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>height</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>col</name>
                <type>com.threed.jpct.RGBColor</type>
            </parameter>
        </method>
        <method>
            <name>Initialize6</name>
            <comment>Creates a texture using a Drawable. jPCT supports every format that JAVA 
 supports for creating images from files as long as the result is a 24bpp 
 image. A texture has to be added to a TextureManager to be of any use for
 the engine. Supported texture sizes are 8, 16, 32, 64, 128, 256, 512, 
 1024, 2048, 4096 and 8192 pixels in width and height. Any texture using 
 other dimensions will raise an error. This method can be used to load a 
 texture that provides an additional alpha channel.
 -
 image - the Drawable
 useAlpha - use alpha information from texture?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>image</name>
                <type>android.graphics.drawable.Drawable</type>
            </parameter>
            <parameter>
                <name>useAlpha</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>Initialize7</name>
            <comment>Creates a black texture with no alpha in the given dimensions.
 -
 width - the width of the texture. Has to be a power of 2.
 height - the height of the texture. Has to be a power of 2.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>width</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>height</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>Initialize4</name>
            <comment>Creates a texture using a Bitmap. jPCT supports every format that JAVA 
 supports for creating images from files as long as the result is a 24bpp 
 image. A texture has to be added to a TextureManager to be of any use for 
 the engine. Supported texture sizes are 8, 16, 32, 64, 128, 256, 512, 
 1024, 2048, 4096 and 8192 pixels in width and height. Any texture using 
 other dimensions will raise an error. This method can be used to load a 
 texture that provides an additional alpha channel.
 -
 image - the Bitmap
 useAlpha - use alpha information from texture?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>image</name>
                <type>android.graphics.Bitmap</type>
            </parameter>
            <parameter>
                <name>useAlpha</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>Initialize5</name>
            <comment>Creates a texture using a Drawble. jPCT supports every format that JAVA 
 supports for creating images from files as long as the result is a 24bpp 
 image. A texture has to be added to a TextureManager to be of any use for 
 the engine. Supported texture sizes are 8, 16, 32, 64, 128, 256, 512, 
 1024, 2048, 4096 and 8192 pixels in width and height. Any texture using 
 other dimensions will raise an error.
 -
 image - the Bitmap</comment>
            <returntype>void</returntype>
            <parameter>
                <name>image</name>
                <type>android.graphics.drawable.Drawable</type>
            </parameter>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Creates a texture using an image from file (usually in jpeg format). jPCT
 supports every format that JAVA supports for creating images from files as 
 long as the result is a 24bpp image. A texture has to be added to a 
 TextureManager to be of any use for the engine. Supported texture sizes 
 are 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096 and 8192 pixels in width 
 and height. Any texture using other dimensions will raise an error. This 
 variant can be used to get the data from an InputStream (for accessing files 
 via getResourceAsStream() for example) This method can be used to load a 
 texture that provides an additional alpha channel.
 -
 is - the InputStream containing the data
 useAlpha - use alpha information from texture?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>is</name>
                <type>java.io.InputStream</type>
            </parameter>
            <parameter>
                <name>useAlpha</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>Initialize3</name>
            <comment>Creates a texture using a Bitmap. jPCT supports every format that JAVA 
 supports for creating images from files as long as the result is a 24bpp 
 image. A texture has to be added to a TextureManager to be of any use for 
 the engine. Supported texture sizes are 8, 16, 32, 64, 128, 256, 512, 
 1024, 2048, 4096 and 8192 pixels in width and height. Any texture using 
 other dimensions will raise an error.
 -
 image - the Bitmap</comment>
            <returntype>void</returntype>
            <parameter>
                <name>image</name>
                <type>android.graphics.Bitmap</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>Initialize</name>
            <comment>Creates a texture using an image from file. jPCT supports every format that 
 JAVA supports for creating images from files as long as the result is a 24bpp 
 image. A texture has to be added to a TextureManager to be of any use for the 
 engine. Supported texture sizes are 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 
 4096 and 8192 pixels in width and height. Any texture using other dimensions 
 will raise an error. This variant can be used to get the data from an 
 InputStream (for accessing files via getResourceAsStream() for example)
 -
 is - the InputStream for the data</comment>
            <returntype>void</returntype>
            <parameter>
                <name>is</name>
                <type>java.io.InputStream</type>
            </parameter>
        </method>
        <method>
            <name>DEFAULT_HEIGHT</name>
            <comment>The default height of a texture (16 pixels).</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>removeAlpha</name>
            <comment>Removes any alpha information from a texture.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>isEnabled</name>
            <comment>Returns if the texture is enabled or not. A disabled texture won't show up when used 
 on any texture stage except the first one.
 -</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>compress</name>
            <comment>Compresses the texture so that is uses less main memory. This doesn't effect the memory 
 used inside the gpu. Compressed textures require some more time to upload. If the saved 
 space is less than 5% of the original size, the texture won't be compressed.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>DEFAULT_WIDTH</name>
            <comment>The default width of a texture (16 pixels).</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>removeEffect</name>
            <comment>Removes an ITextureEffect from the Texture</comment>
            <returntype>void</returntype>
        </method>
        <property>
            <name>Enabled</name>
            <parameter>
                <name>isEnabled</name>
                <type>boolean</type>
            </parameter>
            <comment>Sets the texture to enable/disabled. A disabled texture won't show up when used on 
 any texture stage except the first one. Default it true.
 -
 isEnabled - is it enabled?</comment>
        </property>
        <property>
            <name>Mipmap</name>
            <parameter>
                <name>mipmap</name>
                <type>boolean</type>
            </parameter>
            <comment>Enabled/Disables mip map setting for a texture. Default is true.
 mipmap - true, if there's no override. false means no mip mapping/trilinear for this texture</comment>
        </property>
        <property>
            <name>Filtering</name>
            <parameter>
                <name>filter</name>
                <type>boolean</type>
            </parameter>
            <comment>Sets the bilinear filtering state on textures. Setting this to false forces jPCT to use 
 a pick nearest on the textures. This may also affect mip mapping.
 -
 filter - the mode, true for bilinear, false for pick nearest</comment>
        </property>
        <property>
            <name>ArraySize</name>
            <returntype>int</returntype>
            <comment>Returns the size of the texture array.</comment>
        </property>
        <property>
            <name>Clamping</name>
            <parameter>
                <name>clamping</name>
                <type>boolean</type>
            </parameter>
            <comment>Set texture coordinate to clamping or wrapping/repeating. Calling this on an already 
 uploaded texture forces a new texture upload to the graphics card.
 -
 clamping - clamping or wrapping/repeating?</comment>
        </property>
        <property>
            <name>Height</name>
            <returntype>int</returntype>
            <comment>Returns the height of the texture in pixels.</comment>
        </property>
        <property>
            <name>Effect</name>
            <parameter>
                <name>effect</name>
                <type>com.threed.jpct.ITextureEffect</type>
            </parameter>
            <comment>Sets an effect for this texture. The effect is an implementation of ITextureEffect.
 -
 effect - the effect</comment>
        </property>
        <property>
            <name>AsShadowMap</name>
            <parameter>
                <name>isShadowMap</name>
                <type>boolean</type>
            </parameter>
            <comment>Marks this texture as a shadow map. This only affects the OpenGL ES 2.0 mode.
 -
 isShadowMap - is it a shadow map or not?</comment>
        </property>
        <property>
            <name>TextureCompression</name>
            <parameter>
                <name>enabled</name>
                <type>boolean</type>
            </parameter>
            <comment>Enables ETC1-texture compression if available on the platform. If not, jPCT-AE will 
 fall back to normal textures. This is an experimental feature for now. The usual 
 restrictions for ETC1 apply.
 -
 enabled - enable ETC1 texture compression</comment>
        </property>
        <property>
            <name>DepthBuffer</name>
            <returntype>com.threed.jpct.DepthBuffer</returntype>
            <parameter>
                <name>depthBuffer</name>
                <type>com.threed.jpct.DepthBuffer</type>
            </parameter>
            <comment>?</comment>
        </property>
        <property>
            <name>Width</name>
            <returntype>int</returntype>
            <comment>Returns the width of the texture in pixels.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JSkyBox</name>
        <shortname>jpctSkyBox</shortname>
        <objectwrapper>com.threed.jpct.util.SkyBox</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Creates a new skybox. This constructor assumes that the textures for front, 
 back, left, right, up and down have already been added to the TextureManager 
 and that their names are equal to their purpose, i.e. the front texture is 
 called "front", the left one "left" and so on.
 -
 size - the size of the box. The box will extend in all directions by half the 
 size when viewed from the center.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>size</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>dispose</name>
            <comment>Disposes the skybox. It can't be used after this.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>compile</name>
            <comment>Can be used to compile the skybox to avoid compilation at runtime. Usually not needed,
 just here from compatibility with desktop jPCT.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Creates a new skybox. This constructor assumes that the textures for front, 
 back, left, right, up and down have already been added to the TextureManager.
 -
 left - the name of the texture for the left side
 front - the name of the texture for the front side
 right - the name of the texture for the right side
 back - the name of the texture for the back side
 up - the name of the texture for the up side
 down - the name of the texture for the down side
 size - the size of the box. The box will extend in all directions by half the 
 size when viewed from the center.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>left</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>front</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>right</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>back</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>up</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>down</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>size</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>render</name>
            <comment>Renders the skybox. This should be called before rendering the actual scene or the skybox
 may overwrite transparent polygons.
 -
 world - the world that contains the scene
 buffer - the frame buffer</comment>
            <returntype>void</returntype>
            <parameter>
                <name>world</name>
                <type>com.threed.jpct.World</type>
            </parameter>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
        </method>
        <property>
            <name>Center</name>
            <parameter>
                <name>trans</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <comment>Sets the center of the skybox. This can be useful if the scene's center is way off from 
 the origin. Default is the origin.
 -
 trans -</comment>
        </property>
        <property>
            <name>World</name>
            <returntype>com.threed.jpct.World</returntype>
            <comment>Gets the world that this skybox uses. This might be needed if you want to make 
 additional adjustments to it. By default, it's a default world instance with an 
 ambient light of white. The first object in this world is the sky box.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JSimpleVector</name>
        <shortname>JpctSimpleVector</shortname>
        <objectwrapper>com.threed.jpct.SimpleVector</objectwrapper>
        <owner>process</owner>
        <method>
            <name>matMul</name>
            <comment>Multiplies the SimpleVector with a matrix, i.e. it applies the matrix's 
 transformation to the SimpleVector.
 -
 mat - Matrix the matrix (usually a rotation or a translation matrix)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>mat</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
        </method>
        <method>
            <name>calcCross</name>
            <comment>Calculates the cross product of two SimpleVectors.
 -
 vec - the second SimpleVector</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>vec</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>sub</name>
            <comment>Subtracts another SimpleVector from this SimpleVector without creating a new instance.
 -
 vec - the SimpleVector to subtract</comment>
            <returntype>void</returntype>
            <parameter>
                <name>vec</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>calcAngleFast</name>
            <comment>Calculates the angle between this SimpleVector and another one. This method is 
 faster than the "normal" method, but less accurate.
 -
 vec - the other vector</comment>
            <returntype>float</returntype>
            <parameter>
                <name>vec</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>calcAdd</name>
            <comment>Add two SimpleVectors to a new SimpleVector.
 -
 vec - the second SimpleVector</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>vec</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>rotate</name>
            <comment>Rotates this SimpleVector using the angles (x,y,z) of rotVector. The result is a new 
 SimpleVector. If you want to rotate the SimpleVector itself without creating a new one, 
 use rotateX(), rotateY() and rotateZ() instead.	
 -
 rotVector - the rotation vector containing the angles for the rotations around x,y and z axis.</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>rotVector</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>set</name>
            <comment>Sets the x,y and z values of the SimpleVector to the given floats.
 -
 x - float
 y - float
 z - float</comment>
            <returntype>void</returntype>
            <parameter>
                <name>x</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>z</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>rotateX</name>
            <comment>Rotates the SimpleVector around the x-axis. This method modifies the SimpleVector 
 itself (unlike rotate()).
 -
 angle - the angle</comment>
            <returntype>void</returntype>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>calcDot</name>
            <comment>Calculates the dot product of two SimpleVectors.
 -
 vec - the second SimpleVector</comment>
            <returntype>float</returntype>
            <parameter>
                <name>vec</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>hashCode</name>
            <comment>Overrides hashCode() from java.lang.Object. This is required when overriding equals(), 
 which this implementation does, so...</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>rotateZ</name>
            <comment>Rotates the SimpleVector around the z-axis. This method modifies the SimpleVector 
 itself (unlike rotate()).
 -
 angle - the angle</comment>
            <returntype>void</returntype>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>rotateY</name>
            <comment>Rotates the SimpleVector around the y-axis. This method modifies the SimpleVector 
 itself (unlike rotate()).
 -
 angle - the angle</comment>
            <returntype>void</returntype>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>add</name>
            <comment>Adds another SimpleVector to this SimpleVector without creating a new instance.
 -
 vec - the SimpleVector to add</comment>
            <returntype>void</returntype>
            <parameter>
                <name>vec</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>create2</name>
            <comment>Another way to create a SimpleVector. Using this way, the returned SimpleVector 
 may come from an internal cache of SimpleVectors. Don't use this method to create 
 SimpleVectors that live long but consider to use it for short-living objects.
 -
 sv - the source vector</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>sv</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>create3</name>
            <comment>Another way to create a SimpleVector. Using this way, the returned SimpleVector may 
 come from an internal cache of SimpleVectors. Don't use this method to create 
 SimpleVectors that live long but consider to use it for short-living objects.
 -
 x - the x component
 y - the y component
 z - the z component</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>x</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>z</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>makeEqualLength</name>
            <comment>Makes this SimpleVector the length of another SimpleVector, but only if its longer than this.
 -
 vec - the SimpleVector that defines the length</comment>
            <returntype>void</returntype>
            <parameter>
                <name>vec</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>normalize</name>
            <comment>Normalizes a SimpleVector and returns a normalized vector as a new SimpleVector. 
 To reach a higher numerical accuracy, this method works with doubles instead of 
 float internally.</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
        </method>
        <method>
            <name>distance</name>
            <comment>Returns the distance between this SimpleVector and another position vector.
 -
 pos -</comment>
            <returntype>float</returntype>
            <parameter>
                <name>pos</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>normalize2</name>
            <comment>Normalizes a SimpleVector and returns a normalized vector as a new SimpleVector. 
 To reach a higher numerical accuracy, this method works with doubles instead of 
 float internally. This variant takes a SimpleVector to fill, i.e. it avoids the 
 creation of a new SimpleVector.
 -
 sv - the SimpleVector to fill</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>sv</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>length</name>
            <comment>Gives the length of this SimpleVector</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>Initialize4</name>
            <comment>Creates a new SimpleVector from an existing one
 -
 s - the SimpleVector to "copy"</comment>
            <returntype>void</returntype>
            <parameter>
                <name>s</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>Initialize5</name>
            <comment>Creates a new SimpleVector from an array[3] of floats
 vector - the array containing the x, y and z components of the vector 
 -
 in [0],[1] and [2].</comment>
            <returntype>void</returntype>
            <parameter>
                <name>vector</name>
                <type>float[]</type>
            </parameter>
        </method>
        <method>
            <name>getRotationMatrix3</name>
            <comment>Creates a rotation matrix that can be used to rotate a vector pointing to (0,0,1) to match 
 the direction of this vector. This method takes a matrix to fill, i.e. it doesn't create a 
 new one for each call.
 -
 mat - the Matrix to fill</comment>
            <returntype>com.threed.jpct.Matrix</returntype>
            <parameter>
                <name>mat</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Creates a new SimpleVector by setting the x,y and z components of the vector
 -
 x - the x component
 y - the y component
 z - the z component</comment>
            <returntype>void</returntype>
            <parameter>
                <name>x</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>z</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getRotationMatrix4</name>
            <comment>Creates a rotation matrix that can be used to rotate a vector pointing to (0,0,1) to match 
 the direction of this vector. This method takes a matrix to fill, i.e. it doesn't create a 
 new one for each call.
 -
 up - the up vector used in the calculation
 mat - the Matrix to fill</comment>
            <returntype>com.threed.jpct.Matrix</returntype>
            <parameter>
                <name>mat</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
            <parameter>
                <name>up</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>Initialize3</name>
            <comment>Creates a new SimpleVector by setting the x,y and z components of the vector. 
 This method takes doubles as arguments which are internally casted into floats.
 -
 x - the x component
 y - the y component
 z - the z component</comment>
            <returntype>void</returntype>
            <parameter>
                <name>x</name>
                <type>double</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>double</type>
            </parameter>
            <parameter>
                <name>z</name>
                <type>double</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>getRotationMatrix2</name>
            <comment>Creates a rotation matrix that can be used to rotate a vector pointing to (0,0,1) to match 
 the direction of this vector.
 -
 up - the up vector used in the calculation</comment>
            <returntype>com.threed.jpct.Matrix</returntype>
            <parameter>
                <name>up</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>Initialize</name>
            <comment>Constructor to Initialize the SimpleVector</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>toArray</name>
            <comment>Returns an float[3]-array containing the components of the vector so that 
 [0]=x, [1]=y and [2]=z. This method can be used to use SimpleVectors for methods that 
 requires float[3]-arrays. The returned array is allowed to be the same instance over 
 different calls.</comment>
            <returntype>float[]</returntype>
        </method>
        <method>
            <name>equals</name>
            <comment>Overrides the equals()-method from java.lang.Object. Two SimpleVectors are equal, 
 if their x,y and z components are equal.
 -
 obj - the SimpleVector that should be compared to this one</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>obj</name>
                <type>java.lang.Object</type>
            </parameter>
        </method>
        <method>
            <name>calcSub</name>
            <comment>Calculates the difference vector of two SimpleVectors.
 -
 vec - the second SimpleVector</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>vec</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>scalarMul</name>
            <comment>Multiplies the SimpleVector with a scalar.
 -
 scalar - the scalar to multiply with</comment>
            <returntype>void</returntype>
            <parameter>
                <name>scalar</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>create</name>
            <comment>Another way to create a SimpleVector. Using this way, the returned SimpleVector 
 may come from an internal cache of SimpleVectors. Don't use this method to create 
 SimpleVectors that live long but consider to use it for short-living objects.</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
        </method>
        <method>
            <name>ORIGIN</name>
            <comment>A SimpleVector representing the origin (0,0,0).</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
        </method>
        <method>
            <name>calcAngle</name>
            <comment>Calculates the angle between this SimpleVector and another one.
 -
 vec - the other vector</comment>
            <returntype>float</returntype>
            <parameter>
                <name>vec</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>toString</name>
            <comment>Returns this SimpleVector as a String. Useful for debugging.</comment>
            <returntype>java.lang.String</returntype>
        </method>
        <method>
            <name>reflect</name>
            <comment>Reflects this vector on a plane with the given normal.
 faceNormal - the face normal of the reflective plane</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>faceNormal</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <property>
            <name>2</name>
            <parameter>
                <name>s</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <comment>Sets the x,y and z values of this SimpleVector to the ones of the given SimpleVector.
 s - SimpleVector</comment>
        </property>
        <property>
            <name>RotationMatrix</name>
            <returntype>com.threed.jpct.Matrix</returntype>
            <comment>Creates a rotation matrix that can be used to rotate a vector pointing to (0,0,1) to match the 
 direction of this vector.</comment>
        </property>
        <property>
            <name>z</name>
            <returntype>float</returntype>
            <parameter>
                <name>z</name>
                <type>float</type>
            </parameter>
            <comment>Set/Get The Z value of the SimpleVector.</comment>
        </property>
        <property>
            <name>y</name>
            <returntype>float</returntype>
            <parameter>
                <name>y</name>
                <type>float</type>
            </parameter>
            <comment>Set/Get The Y value of the SimpleVector.</comment>
        </property>
        <property>
            <name>x</name>
            <returntype>float</returntype>
            <parameter>
                <name>x</name>
                <type>float</type>
            </parameter>
            <comment>Set/Get The X value of the SimpleVector.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JShaderLocator</name>
        <shortname>JpctShaderLocator</shortname>
        <objectwrapper>com.threed.jpct.ShaderLocator</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Constructor to Initialize the ShaderLocater</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>getShaderCode</name>
            <comment>This is important for OpenGL ES 2.0 support only. If you aren't using this, 
 ignore this class.
 -
 name -</comment>
            <returntype>java.lang.String</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>This is important for OpenGL ES 2.0 support only. If you aren't using this, 
 ignore this class.
 -
 assets -</comment>
            <returntype>void</returntype>
            <parameter>
                <name>assets</name>
                <type>android.content.res.AssetManager</type>
            </parameter>
        </method>
        <method>
            <name>Initialize3</name>
            <comment>This is important for OpenGL ES 2.0 support only. If you aren't using this, 
 ignore this class.
 -
 res - Resources
 rawResourceId - int</comment>
            <returntype>void</returntype>
            <parameter>
                <name>res</name>
                <type>android.content.res.Resources</type>
            </parameter>
            <parameter>
                <name>rawResourceId</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JRGBColor</name>
        <shortname>JpctRGBColor</shortname>
        <objectwrapper>com.threed.jpct.RGBColor</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Creates a new Black color with alpha.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Creates a new color with alpha.
 -
 r - Red (0 - 255)
 g - Green (0 - 255)
 b - Blue (0 - 255)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>r</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>g</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>b</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>Initialize3</name>
            <comment>Creates a new color with alpha.
r,g,b,a: as int</comment>
            <returntype>void</returntype>
            <parameter>
                <name>r</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>g</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>b</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>a</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>setTo</name>
            <comment>Modifies and existing instance of RGBColor.
 -
 r - Red (0 - 255)
 g - Green (0 - 255)
 b - Blue (0 - 255)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>r</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>g</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>b</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>a</name>
                <type>int</type>
            </parameter>
        </method>
        <property>
            <name>NormalizedGreen</name>
            <returntype>float</returntype>
            <comment>Returns the green value in normalized form (0..1).</comment>
        </property>
        <property>
            <name>ARGB</name>
            <returntype>int</returntype>
            <comment>Returns the color as an int argb value with alpha.</comment>
        </property>
        <property>
            <name>Blue</name>
            <returntype>int</returntype>
            <comment>Returns the blue value (0..255).</comment>
        </property>
        <property>
            <name>Alpha</name>
            <returntype>int</returntype>
            <comment>Returns the alpha value (0..255).</comment>
        </property>
        <property>
            <name>Red</name>
            <returntype>int</returntype>
            <comment>Returns the red value (0..255).</comment>
        </property>
        <property>
            <name>NormalizedBlue</name>
            <returntype>float</returntype>
            <comment>Returns the blue value in normalized form (0..1).</comment>
        </property>
        <property>
            <name>NormalizedAlpha</name>
            <returntype>float</returntype>
            <comment>Returns the alpha value in normalized form (0..1).</comment>
        </property>
        <property>
            <name>Green</name>
            <returntype>int</returntype>
            <comment>Returns the green value (0..255).</comment>
        </property>
        <property>
            <name>NormalizedRed</name>
            <returntype>float</returntype>
            <comment>Returns the red value in normalized form (0..1).</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JRenderHook</name>
        <shortname>JpctRenderHook</shortname>
        <objectwrapper>jpct.ae.wrapper.RenderHook</objectwrapper>
        <owner>process</owner>
        <event>RenderHook(rhEvent As Int, polyID As Int, obj As JpctObject3D, transparency As Float, shader As JpctGLSLShader)</event>
        <method>
            <name>EVENT_SET_TRANSPARENCY</name>
            <comment>Event type - SET_TRANSPARENCY - of the callback event raised by the RenderHook.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>Initialize</name>
            <comment>Initialize the Render Hook
 eventName - the name of the Render Hook's event</comment>
            <returntype>void</returntype>
            <parameter>
                <name>ba</name>
                <type>anywheresoftware.b4a.BA</type>
            </parameter>
            <parameter>
                <name>eventName</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>repeatRendering</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>EVENT_SET_OBJECT3D</name>
            <comment>Event type - SET_OBJECT3D - of the callback event raised by the RenderHook.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>EVENT_BEFORE_RENDERING</name>
            <comment>Event type - BEFORE_RENDERING - of the callback event raised by the RenderHook.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>EVENT_DISPOSE</name>
            <comment>Event type - DISPOSE - of the callback event raised by the RenderHook.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>EVENT_AFTER_RENDERING</name>
            <comment>Event type - AFTER_RENDERING - of the callback event raised by the RenderHook.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>EVENT_SET_SHADER</name>
            <comment>Event type - SET_SHADER - of the callback event raised by the RenderHook.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JPrimitives</name>
        <shortname>JpctPrimitives</shortname>
        <objectwrapper>com.threed.jpct.Primitives</objectwrapper>
        <owner>process</owner>
        <method>
            <name>getBox</name>
            <comment>Returns a box (a 3-dimensional rectangle)
 -
 scale - the scaling of the box
 scaleHeight - the height relative to the width (i.e. a scaleHeight-value of 1 will return a cube).</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>scaleHeight</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getEllipsoid</name>
            <comment>Returns an ellipsoid with 20 faces.
 -
 scale - the scaling in x-direction
 scaleHeight - the scaling of the height relative to the width (1 creates a sphere)</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>scaleHeight</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getSphere</name>
            <comment>Returns a sphere with 20 faces.
 -
 scale - the scaling of the sphere</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getCone3</name>
            <comment>Returns a cone with the given number of faces.
 -
 faces - the number of faces
 scale - the scaling of the cone
 scaleHeight - the height relative to the width</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>faces</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>scaleHeight</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getCone2</name>
            <comment>Returns a cone with the given number of faces.
 -
 faces - the number of faces
 scale - the scaling of the cone</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>faces</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getDoubleCone</name>
            <comment>Returns a double cone with 90 faces.
 -
 scale - the scaling of the double cone</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getCone</name>
            <comment>Returns a cone with 90 faces.
 -
 scale - the scaling of the cone</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getPlane</name>
            <comment>Returns a plane consisting of (quads^2)*2 polygons each "scale" units in size. 
 The plane lies within the X-Y-plane and has a depth of 0;
 -
 quads - the number of quads the plane has in x as well as in y direction
 scale - the size of each quad</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>quads</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getPyramide2</name>
            <comment>Returns a pyramide
 -
 scale - the scaling of the pyramide
 scaleHeight - the height relative to the width</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>scaleHeight</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getCube</name>
            <comment>Returns a cube
 -
 scale - the scaling of the cube</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getCylinder</name>
            <comment>Returns a cylinder with 90 faces.
 -
 scale - the scaling of the cylinder</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getCylinder3</name>
            <comment>Returns a cylinder with the given number of faces.
 -
 faces - the number of faces
 scale - the scaling of the cylinder
 scaleHeight - the height relative to the width</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>faces</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>scaleHeight</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getDoubleCone2</name>
            <comment>Returns a double cone with the given number of faces.
 -
 faces - the number of faces
 scale - the scaling of the double cone</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>faces</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getCylinder2</name>
            <comment>Returns a cylinder with the given number of faces.
 -
 faces - the number of faces
 scale - the scaling of the cylinder</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>faces</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>getPyramide</name>
            <comment>Returns a pyramide
 -
 scale - the scaling of the pyramide</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JPostProcessor</name>
        <shortname>JpctPostProcessor</shortname>
        <objectwrapper>jpct.ae.wrapper.PostProcessor</objectwrapper>
        <owner>process</owner>
        <event>PostProcessor (ppEvent As Int, buffer As JpctFrameBuffer)</event>
        <method>
            <name>Initialize</name>
            <comment>Initialize PostProcessor
 eventName - the name of the Vertex Controller's event</comment>
            <returntype>void</returntype>
            <parameter>
                <name>ba</name>
                <type>anywheresoftware.b4a.BA</type>
            </parameter>
            <parameter>
                <name>eventName</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>EVENT_DISPOSE</name>
            <comment>The collision event was caused by a sphere-polygon collision detection.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>EVENT_PROCESS</name>
            <comment>The collision event was caused by a ray-polygon collision detection.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>EVENT_INIT</name>
            <comment>The collision event was caused by a ellipsoid-polygon collision detection.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JPolyline</name>
        <shortname>JpctPolyline</shortname>
        <objectwrapper>com.threed.jpct.Polyline</objectwrapper>
        <owner>process</owner>
        <method>
            <name>update</name>
            <comment>Updates the line strip. The new data has to be equal in size or smaller than the initial strip.
 -
 newPoints - the new points</comment>
            <returntype>void</returntype>
            <parameter>
                <name>newPoints</name>
                <type>com.threed.jpct.SimpleVector[]</type>
            </parameter>
        </method>
        <method>
            <name>Initialize</name>
            <comment>Creates a new, static Polyline.
 -
 points - The coordinates in world space
 color - The color</comment>
            <returntype>void</returntype>
            <parameter>
                <name>points</name>
                <type>com.threed.jpct.SimpleVector[]</type>
            </parameter>
            <parameter>
                <name>color</name>
                <type>com.threed.jpct.RGBColor</type>
            </parameter>
        </method>
        <method>
            <name>isVisible</name>
            <comment>Returns the visibility of the line.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>Percentage</name>
            <returntype>float</returntype>
            <parameter>
                <name>percentage</name>
                <type>float</type>
            </parameter>
            <comment>Returns the percentage (a value between 0 and 1 that defines how much of the line is 
 actually visible).</comment>
        </property>
        <property>
            <name>Visible</name>
            <parameter>
                <name>visible</name>
                <type>boolean</type>
            </parameter>
            <comment>Sets the visibility of the line.
 -
 visible - visible or not?</comment>
        </property>
        <property>
            <name>TransparencyMode</name>
            <returntype>int</returntype>
            <parameter>
                <name>transparencyMode</name>
                <type>int</type>
            </parameter>
            <comment>Returns the current transparency mode.</comment>
        </property>
        <property>
            <name>Length</name>
            <returntype>int</returntype>
            <comment>Returns the length of the line strip. This is the actual length * the value set as percentage.</comment>
        </property>
        <property>
            <name>Width</name>
            <returntype>float</returntype>
            <parameter>
                <name>width</name>
                <type>float</type>
            </parameter>
            <comment>Returns the line width. Default is 1.</comment>
        </property>
        <property>
            <name>Color</name>
            <returntype>com.threed.jpct.RGBColor</returntype>
            <parameter>
                <name>color</name>
                <type>com.threed.jpct.RGBColor</type>
            </parameter>
            <comment>Returns the color of the line strip.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JPolygonManager</name>
        <shortname>JpctPolygonManager</shortname>
        <objectwrapper>com.threed.jpct.PolygonManager</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Initialize PolygonManager
 object3D - the object you want PolygonManager to handle</comment>
            <returntype>void</returntype>
            <parameter>
                <name>object3D</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>getPolygonTextures2</name>
            <comment>Returns the texture IDs of a polygon or null in case of an error. The corresponding 
 textures can be obtained from the TextureManager. The returned array is allowed to 
 contain TextureManager.TEXTURE_NOTFOUND-IDs. In that case, you can break after finding 
 the first one.
 -
 polyID - int the ID of the polygon</comment>
            <returntype>int[]</returntype>
            <parameter>
                <name>polyID</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>getTransformedVertex</name>
            <comment>Returns a polygon's vertex transformed into world space.
 -
 polyID - int the ID of the polygon
 vertexNumber - int the number if the vertex (0..2)</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>polyID</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>vertexNumber</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>setVertexAlpha</name>
            <comment>Sets the alpha value for an objects vertex. Once done on an object, the overall 
 transparency value for this object is obsolete and all transparency will be calculated 
 using the alpha values assigned to the vertices, default is 1.
 -
 polyID - int the ID of the polygon
 vertexNumber - int the number if the vertex (0..2)
 alpha - the new alpha value in a range of (0..1)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>polyID</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>vertexNumber</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>alpha</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getTextureUV</name>
            <comment>Returns the normalized texture coordinates mapped to a SimpleVector's x and y component.
 -
 polyID - int the ID of the polygon
 vertexNumber - int the number if the vertex (0..2)</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>polyID</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>vertexNumber</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>addTexture</name>
            <comment>Adds a texture to next free stage, if another free stage is available.
 -
 polyID - the polygon id
 tid - the texture's id
 mode - the blending mode (as defined in TextureInfo)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>polyID</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>tid</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>setPolygonTexture</name>
            <comment>Sets the texture for a polygon. The texture ID is the ID of the texture in the World 
 instance to which this object is assigned. It can be obtained by calling 
 TextureManager.getTextureID(). The polygon's ID is what the picking methods in 
 Interact2D or a CollisionEvent may return.
 -
 polyID - the ID of the polygon
 textureID - the ID of the texture</comment>
            <returntype>void</returntype>
            <parameter>
                <name>polyID</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>textureID</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>getPolygonTexture</name>
            <comment>Returns the texture ID of a polygon or -1 in case of an error. The corresponding
 texture can be obtained from the TextureManager.
 -
 polyID - int the ID of the polygon</comment>
            <returntype>int</returntype>
            <parameter>
                <name>polyID</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>getTransformedNormal</name>
            <comment>Returns a polygon's face normal transformed into world space.
 -
 polyID - int the ID of the polygon</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>polyID</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>MaxPolygonID</name>
            <returntype>int</returntype>
            <comment>Returns the maximum polygon ID for the object.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JPaintListener</name>
        <shortname>JpctPaintListener</shortname>
        <objectwrapper>jpct.ae.wrapper.PaintListener</objectwrapper>
        <owner>process</owner>
        <event>PaintListener(plEvent as int)</event>
        <method>
            <name>Initialize</name>
            <comment>Initialize the Paint Listener
 eventName - the name of the Paint Listener's event</comment>
            <returntype>void</returntype>
            <parameter>
                <name>ba</name>
                <type>anywheresoftware.b4a.BA</type>
            </parameter>
            <parameter>
                <name>eventName</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>EVENT_FINISHED</name>
            <comment>Called when the renderer has finished painting.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>EVENT_START</name>
            <comment>Called when the renderer starts painting.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JOverlay</name>
        <shortname>JpctOverlay</shortname>
        <objectwrapper>com.threed.jpct.util.Overlay</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Creates a new overlay that covers the whole screen.
 -
 world - the world
 buffer - the current frame buffer
 textureName - the name of the texture that should be used as an overlay. 
 The TextureManager has to know this texture.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>world</name>
                <type>com.threed.jpct.World</type>
            </parameter>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>textureName</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>update</name>
            <comment>Updates the overlay. It shouldn't be required to call this method from a normal application.
 -
 buffer -</comment>
            <returntype>void</returntype>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
        </method>
        <method>
            <name>dispose</name>
            <comment>Disposes the overlay and frees its resources. It can't be used after calling this method</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>setRotationPivot</name>
            <comment>Sets the pivot point for the rotation in screen coordinates.
 -
 x - the x position
 y - the y position</comment>
            <returntype>void</returntype>
            <parameter>
                <name>x</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>unlink</name>
            <comment>Unlinks the overlay. It shouldn't be required to call this method from a normal application.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>setSourceCoordinates</name>
            <comment>Sets new source coordinates. Only the defined part of the source texture will be used as an overlay.
 Setting this will slow the overlay down a tiny little bit, but that shouldn't be noticable.
 -
 upperLeftX - the upper left corner's x-coordinate in texture coordinates
 upperLeftY - the upper left corner's y-coordinate in texture coordinates
 lowerRightX - the lower right corner's x-coordinate in texture coordinates
 lowerRightY - the lower right corner's y-coordinate in texture coordinates</comment>
            <returntype>void</returntype>
            <parameter>
                <name>upperLeftX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>upperLeftY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>lowerRightX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>lowerRightY</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Creates a new overlay of arbritary size.
 -
 world - the world
 upperLeftX - the upper left corner's x-coordinate in screen coordinates
 upperLeftY - the upper left corner's y-coordinate in screen coordinates
 lowerRightX - the lower right corner's x-coordinate in screen coordinates
 lowerRightY - the lower right corner's y-coordinate in screen coordinates
 textureName - the name of the texture that should be used as an overlay. 
 The TextureManager has to know this texture.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>world</name>
                <type>com.threed.jpct.World</type>
            </parameter>
            <parameter>
                <name>upperLeftX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>upperLeftY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>lowerRightX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>lowerRightY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>textureName</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>Initialize3</name>
            <comment>Creates a new overlay of arbritary size with (optional) modifiable uv-coordinates.
 -
 world - the world
 upperLeftX - the upper left corner's x-coordinate in screen coordinates
 upperLeftY - the upper left corner's y-coordinate in screen coordinates
 lowerRightX - the lower right corner's x-coordinate in screen coordinates
 lowerRightY - the lower right corner's y-coordinate in screen coordinates
 textureName - the name of the texture that should be used as an overlay.
 The TextureManager has to know this texture.
 modifyUV - if true, uv-coordinates can be modified.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>world</name>
                <type>com.threed.jpct.World</type>
            </parameter>
            <parameter>
                <name>upperLeftX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>upperLeftY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>lowerRightX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>lowerRightY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>textureName</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>modifyUV</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>setNewCoordinates</name>
            <comment>Sets new coordinates for the overlay.
 -
 upperLeftX - the upper left corner's x-coordinate in screen coordinates
 upperLeftY - the upper left corner's y-coordinate in screen coordinates
 lowerRightX - the lower right corner's x-coordinate in screen coordinates
 lowerRightY - the lower right corner's y-coordinate in screen coordinates</comment>
            <returntype>void</returntype>
            <parameter>
                <name>upperLeftX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>upperLeftY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>lowerRightX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>lowerRightY</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>Transparency</name>
            <parameter>
                <name>trans</name>
                <type>int</type>
            </parameter>
            <comment>Set the transparency of the overlay. The trans-value behaves as the value in Object3D's 
 setTransparency()-method. By default, the overlay is opaque.
 -
 trans - the transparency value</comment>
        </property>
        <property>
            <name>Object3D</name>
            <returntype>com.threed.jpct.Object3D</returntype>
            <comment>Returns the internal Object3D that is the actual Overlay. Handle with care!</comment>
        </property>
        <property>
            <name>TransparencyMode</name>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <comment>Sets the transparency mode similar to setTransparencyMode() in Object3D.
 -
 mode - the mode</comment>
        </property>
        <property>
            <name>Visibility</name>
            <parameter>
                <name>visible</name>
                <type>boolean</type>
            </parameter>
            <comment>Sets the visibility similar to setVisibility() in Object3D.
 -
 visible - should it be visible or not?</comment>
        </property>
        <property>
            <name>Rotation</name>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
            <comment>Rotates the Overlay around it's midpoint.
 -
 angle - the angle</comment>
        </property>
        <property>
            <name>Depth</name>
            <parameter>
                <name>depth</name>
                <type>float</type>
            </parameter>
            <comment>Sets the depth of the overlay. By default the overlay is bound to Config.nearPlane
 with a small offset. By setting this to a higher value, the overlay will ovberlap 
 differently with other objects in the world while still filling the whole screen. 
 Useful for using an (pseudo-)overlay as static backdrop. When using a large overlay, 
 the accuracy may suffer. In this case, it might also help to increase the depth value.
 -
 depth - the new depth (should be positive)</comment>
        </property>
        <property>
            <name>Texture2</name>
            <parameter>
                <name>textureInfo</name>
                <type>com.threed.jpct.TextureInfo</type>
            </parameter>
            <comment>Changes the texture of the overlay.
 -
 textureInfo - the new TextureInfo.</comment>
        </property>
        <property>
            <name>Texture</name>
            <parameter>
                <name>textureName</name>
                <type>java.lang.String</type>
            </parameter>
            <comment>Changes the texture of the overlay.
 -
 textureName - the new texture's name as the TextureManager knows it.</comment>
        </property>
        <property>
            <name>Color</name>
            <parameter>
                <name>color</name>
                <type>com.threed.jpct.RGBColor</type>
            </parameter>
            <comment>Sets a new additional color. With this, it's possible to give the overlay another coloring. 
 Default is white, i.e. the overlay shows the same colors like they are defined in the texture.
 -
 color - the new Color</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JOcTree</name>
        <shortname>JpctOcTree</shortname>
        <objectwrapper>com.threed.jpct.OcTree</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Initialize OcTree</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>RENDERING_DONT_USE</name>
            <comment>Don't use this octree to speed up rendering.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>MODE_NORMAL</name>
            <comment>Builds the octree in the "normal" way.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>COLLISION_DONT_USE</name>
            <comment>Don't use this octree to speed up collision detection.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>MODE_OPTIMIZED</name>
            <comment>Tries to build a more optimized octree. In the current implementation, 
 this will reduce the size of the tree in memory but it may take a bit 
 longer to build the tree.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>COLLISION_USE</name>
            <comment>Use this octree to speed up collision detection.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>isOfOrderZero</name>
            <comment>If the root-node is the only node in the tree, the tree is of order zero. In that case, 
 using the generated octree is at least questionable. This can be used to assign 
 (to an Object3D) trees of a higher order only.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>Initialize4</name>
            <comment>Builds a new octree from an Object3D. The tree may then be assigned to the object 
 (this is NOT done automatically). This constructor doesn't set the maximum depth 
 of the OcTree, so the tree may become very big and the recursion may fail on large 
 objects.
 -
 obj - the object from which's mesh the octree should be constructed
 maxPoly - the maximum number of polygons a single node may contain. The smaller 
 this number is, the more complex the octree gets. It depends on the object and its 
 usage which number will be the best.
 mode - the mode that should be used to construct the object</comment>
            <returntype>void</returntype>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
            <parameter>
                <name>maxPoly</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>Initialize5</name>
            <comment>Builds a new octree from an Object3D. The tree may then be assigned to the object 
 (this is NOT done automatically).
 -
 obj - the object from which's mesh the octree should be constructed
 maxPoly - the maximum number of polygons a single node may contain. The smaller this 
 number is, the more complex the octree gets. It depends on the object and its usage 
 which number will be the best.
 maxDepth - the maximum depth of the tree. The recursion will end at this depth 
 regardless of the number of polygons in the node.
 mode - the mode that should be used to construct the object</comment>
            <returntype>void</returntype>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
            <parameter>
                <name>maxPoly</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>maxDepth</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Builds a new octree from an Object3D. The tree may then be assigned to the object 
 (this is NOT done automatically). This constructor doesn't set the maximum depth of 
 the OcTree, so the tree may become very big and the recursion may fail on large objects.
 -
 mesh - the mesh from which the octree should be constructed
 maxPoly - the maximum number of polygons a single node may contain. The smaller this 
 number is, the more complex the octree gets. It depends on the object and its usage 
 which number will be the best.
 mode - the mode that should be used to construct the object</comment>
            <returntype>void</returntype>
            <parameter>
                <name>mesh</name>
                <type>com.threed.jpct.Mesh</type>
            </parameter>
            <parameter>
                <name>maxPoly</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>Initialize3</name>
            <comment>Builds a new octree from an Object3D. The tree may then be assigned to the object 
 (this is NOT done automatically).
 -
 mesh - the mesh from which the octree should be constructed
 maxPoly - the maximum number of polygons a single node may contain. The smaller this 
 number is, the more complex the octree gets. It depends on the object and its usage
 which number will be the best.
 maxDepth - the maximum depth of the tree. The recursion will end at this depth 
 regardless of the number of polygons in the node.
 mode - the mode that should be used to construct the object</comment>
            <returntype>void</returntype>
            <parameter>
                <name>mesh</name>
                <type>com.threed.jpct.Mesh</type>
            </parameter>
            <parameter>
                <name>maxPoly</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>maxDepth</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>RENDERING_USE</name>
            <comment>Use this octree to speed up rendering.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>FilledLeafs</name>
            <returntype>java.util.ArrayList</returntype>
            <comment>?</comment>
        </property>
        <property>
            <name>RadiusMultiplier</name>
            <returntype>float</returntype>
            <parameter>
                <name>mul</name>
                <type>float</type>
            </parameter>
            <comment>Returns the current radius multiplier for this octree.</comment>
        </property>
        <property>
            <name>CollisionUse</name>
            <returntype>boolean</returntype>
            <parameter>
                <name>useIt</name>
                <type>boolean</type>
            </parameter>
            <comment>Gets the collision detection setting for this octree.</comment>
        </property>
        <property>
            <name>RenderingUse</name>
            <returntype>boolean</returntype>
            <parameter>
                <name>useIt</name>
                <type>boolean</type>
            </parameter>
            <comment>Gets the rendering usage setting for this octree.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JObject3D</name>
        <shortname>JpctObject3D</shortname>
        <objectwrapper>com.threed.jpct.Object3D</objectwrapper>
        <owner>process</owner>
        <method>
            <name>animate</name>
            <comment>Calculates a new mesh for this object based on the keyframes of its animation sub-sequence 
 and "index". index is a value between 0 and 1 where 0 is the first keyframe and 1 the last 
 (of the sub-sequence). If seq is zero, the whole animation will be treated as a sub-sequence.
 -
 index - the "time-index" into the sub-sequence of the animation
 seq - the number of the sub.sequence (sub-sequence start at 1, 0 stands for the animation as a whole)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>index</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>seq</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>isTransparent</name>
            <comment>Returns if the object is transparent of not.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>setBoundingBox</name>
            <comment>Sets a new AABB for the object. Usually, this shouldn't be required as it is automatically done by 
 the build()-method.
 -
 minx - the lowest x-value of the AABB
 maxx - the highest x-value of the AABB
 miny - the lowest y-value of the AABB
 maxy - the highest y-value of the AABB
 minz - the lowest z-value of the AABB
 maxz - the highest z-value of the AABB</comment>
            <returntype>void</returntype>
            <parameter>
                <name>minx</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>maxx</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>miny</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>maxy</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>minz</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>maxz</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>clearShader</name>
            <comment>Removes a shader and reverts to the default shader set. This is only valid when using 
 OpenGL ES 2.0.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>setOrientation</name>
            <comment>Sets the orientation of this object by giving a direction and an up-vector.
 -
 dir - the direction
 up - the up-vector</comment>
            <returntype>void</returntype>
            <parameter>
                <name>dir</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>up</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>TRANSPARENCY_MODE_ADD</name>
            <comment>An alternative transparency mode for additive blending.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>build2</name>
            <comment>Initializes some basic object properties that are needed for almost all further processing.
 build() has to be called if the object is "ready to render" (loaded, Textures assigned, placed,
 rendering modes set, animations and vertex controllers assigned). This method is a special 
 purpose method that has to be used if an UV-coordinates are supposed to be modified.
 staticUV -</comment>
            <returntype>void</returntype>
            <parameter>
                <name>staticUV</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>COLLISION_CHECK_SELF</name>
            <comment>This Object3D may collide with other objects</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>hasVertexAlpha</name>
            <comment>Returns true, if this object uses vertex alpha values. False, if it doesn't, which is default.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>shareTextureData</name>
            <comment>In addition to sharing the actual mesh data, you can also make objects share the same texturing information 
 (the actual textures, not the uv-coordinates). If you do this, changing the texture on one object will change 
 it on all sharing objects too. This helps to save some memory, especially on objects that use multiple textures.
 -
 source - the source of the texturing information</comment>
            <returntype>void</returntype>
            <parameter>
                <name>source</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>SPECULAR_DISABLED</name>
            <comment>Specular highLights won't be calculated.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>sphereIntersectsAABB</name>
            <comment>Checks if a given sphere intersects the axis aligned bounding box (in object-space) of this object. This can be 
 useful to speed up some calculations. jPCT is using this method for faster collision detection. "Intersection"
 means everything from touching it to being completely covered by it in this case. If the object doesn't have a 
 bounding box for whatever reason, false will be returned.
 -
 org - the position vector of the sphere (the sphere's center)
 radius - the radius of the sphere</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>org</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>radius</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getInverseWorldTransformation2</name>
            <comment>getInverseWorldTransformation ?
 mat - Matrix ?</comment>
            <returntype>com.threed.jpct.Matrix</returntype>
            <parameter>
                <name>mat</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
        </method>
        <method>
            <name>calcTextureWrapSpherical</name>
            <comment>"Wraps" a texture around the object in a spherical way. Usually, this method produces better results than 
 calcTextureWrap(), but it depends on the object. This method is well suited to assign texture-coordinates 
 to objects that were generated using the Primitives class. This method recalculates the center of the object, 
 so any modification to the center or the rotation-pivot will be lost after calling this method.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>removeChild</name>
            <comment>Removes an object from the child-collection of this. The object itself won't be removed.
 -
 obj - the Object3D to remove</comment>
            <returntype>void</returntype>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>resetNextID</name>
            <comment>Resets the internal object-counter.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>calcBoundingBox</name>
            <comment>Calculates an AABB (Axis Aligned Bounding Box) for this object in object-space. The box will 
 then be transformed together with the object so that it becomes an OBB (oriented bounding box) 
 when the object will be transformed. Normally, there is no need to call this method directly, 
 because it will already be called from the build() method. Exceptions could be the use of objects
 meshes for animation and similar tasks.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>touch</name>
            <comment>Touches an object. This has a meaning for dynamically compiled objects and for objects that use 
 lazy transformations. If touched, changes in vertices (and u/v-coordinates if supported) will be 
 retransfered to the graphics card and the transformation matrices of objects using lazy 
 transformations will be recalculated.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>enableLazyTransformations</name>
            <comment>Enables "lazy transformations". When lazy transformations are being used, the world-transformation 
 matrix (as well as its inverse if needed) is calculated only once and used from there on until lazy 
 transformations are being disabled again. This helps to improve performance for static objects and 
 it can be VERY helpful to speed-up collision detection with such objects. It may also be used on 
 none-static objects if they aren't moving/rotating for some time (for example: if a lot of objects 
 should be checked for collision, it could be helpful to enable lazy transformations before doing this 
 and disabling it right after the tests). Enabling this again after it already has been clears the 
 stored values, i.e. you can use this to update the calculated matrix inbetween without disabling the
 mode entirely.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>addChild</name>
            <comment>Defines an object as a child of this. A child object will inherit all transformations but no 
 other attributes of this object.
 -
 obj - the object that should become a child of this.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>checkForCollisionEllipsoid</name>
            <comment>Checks if the current object collides with something when moving into a particular direction. This is just a 
 check, so no translations are being performed. A collision can only be detected with objects that are set to 
 COLLISION_CHECK_OTHERS. This method uses a (swept)ellipsoid-polygon collision detection.
 -
 translation - the translation the object should perform
 ellipsoid - the radius of the epplisoid in x,y and z direction
 recursionDepth - the max. recursion depth of the collision detection. A higher value will improve the accuracy 
 of the collision detection but reduce performance. Reasonable values lie between 1 and 5.</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>translation</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>ellipsoid</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>recursionDepth</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>shareCompiledData</name>
            <comment>Enables a compiled object to share data with another compiled one. This helps to save system 
 or GPU memory, depending on the used mode for compilation. The object you would like to share 
 data with must not share data itself with some other, it must not use an octree. Furthermore,
 both objects have to use the same mesh (not just the same data but the exact same instance), 
 this object must not share data with some other. This object will inherit all texture 
 coordinates and vertex alpha values from the source object no matter what may have been 
 assigned to it.
 -
 withObj - the object to share data with</comment>
            <returntype>void</returntype>
            <parameter>
                <name>withObj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>ellipsoidIntersectsAABB</name>
            <comment>Checks if a given ellipsoid intersects the axis aligned bounding box (in object-space) of this object. This can 
 be useful to speed up some calculations. jPCT is using this method for faster collision detection. "Intersection" 
 means everything from touching it to being completely covered by it in this case. If the object doesn't have a 
 bounding box for whatever reason, false will be returned.
 -
 org - the position vector of the ellipsoid (the ellipsoid's center)
 ellipsoid - the radius of the ellipsoid in x,y and z-direction as a SimpleVector</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>org</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>ellipsoid</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>forceGeometryIndices</name>
            <comment>Forces the object to be compiled to indexed geometry no matter what. Default is false and jPCT 
 will try to figure out, what is best for an object. If this is true, it will override this 
 detection. Compiling to indexed geometry is more expensive, the result might be smaller in
 memory and depending on the device, it will be rendered faster or slower... This has to be set 
 before calling build() to have an effect.
 -
 force - should we?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>force</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>COLLISION_DETECTION_OPTIMIZED</name>
            <comment>Enables an automated optimization for speeding up collision detection in 
 some case. May cause problems on dynamically changing geometry.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>build</name>
            <comment>Initializes some basic object properties that are needed for almost all further processing. 
 build() has to be called if the object is "ready to render" (loaded, Textures assigned, placed, 
 rendering modes set, animations and vertex controllers assigned).</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>addParent</name>
            <comment>Defines an object as a parent of this. this will inherit all transformations from its parent 
 and no other attributes. Defining child and parent object is basically the same. Child object 
 of A will internally be stored by assigning A as their parent. It's a matter of taste which 
 kind of logic one may use. Therefor, both are supported but the parent-logic is closer to the 
 implementation...then again: Who cares?
 -
 obj - the object that should become a parent of this.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>UNKNOWN_OBJECTSIZE</name>
            <comment>The object is empty</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>invert</name>
            <comment>Physically "inverts" the object, which means that the backface culling works the other way round. This could 
 be used for example on a cube that is usually viewed from outside to make it possible to view it from the inside 
 (and still use backface culling on it). Inverting an object is a costly operation.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>ELLIPSOID_TRANSFORMED</name>
            <comment>The object's ellipsoid will be transformed when performing collision 
 detection.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>compile</name>
            <comment>Mainly needed to ease porting from the desktop version of jPCT. By default, jPCT-AE does 
 this call automatically, so usually there's no need to call this method directly.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>animate2</name>
            <comment>Calculates a new mesh for this object based on the keyframes of its animation sequence and 
 "index". index is a value between 0 and 1 where 0 is the first keyframe and 1 the last. 
 Because no sub-sequence is indicated, the complete animation will be used.
 -
 index - the "time-index" into the animation</comment>
            <returntype>void</returntype>
            <parameter>
                <name>index</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getWorldTransformation2</name>
            <comment>Variant of getWorldTransformation() to avoid the creation of an additional matrix where not needed. The 
 given matrix will be filled with the returns and returned in addition.
 -
 mat - the matrix to be filled</comment>
            <returntype>com.threed.jpct.Matrix</returntype>
            <parameter>
                <name>mat</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
        </method>
        <method>
            <name>getTransformedCenter</name>
            <comment>Returns the center of the object in worldspace, i.e. after the object's current transformations have been 
 applied to it. The returned SimpleVector is the same one as the one given as parameter. This is useful to 
 save the creation of an additional object. If null is given, a new one will be created.
 -
 toFill -</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>toFill</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>hasParent</name>
            <comment>Tests an object for being a parent object of the current object. The object inherits all the 
 transformations from its parent object.
 -
 obj - the object that should be tested for being a parent of this</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>TRANSPARENCY_MODE_DEFAULT</name>
            <comment>The default transparency mode.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>SHADING_FAKED_FLAT</name>
            <comment>Indicates that (faked) flat shading should be used. Faked, because it 
 sits on top of gouraud, i.e. it's not faster than using gouraud shading. 
 In fact it may be slower because it hinders the usage of triangle strips.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>translate</name>
            <comment>Translates ("moves") the object in worldspace by modifying the translation matrix. The translation
 will be applied the next time the object is rendered.
 -
 trans - the translation vector</comment>
            <returntype>void</returntype>
            <parameter>
                <name>trans</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>createDummyObj</name>
            <comment>Static method that creates a dummy Object3D. This dummy object is basically a normal but 
 empty object. This method should be used to create an object that won't be added to the 
 world but linked to another object as a child object. This could be useful to enhance the 
 flexiblity of the object bindings (like a moon spinning around a planet...it may be useful 
 to link the moon to the planet via a dummy object placed in the planet's center. This 
 enables the moon not only to inherit the transformations of the planet but also the 
 transformations of the dummy object). There is no need nor any sense in adding a dummy 
 object directly to the world.</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
        </method>
        <method>
            <name>BILLBOARDING_DISABLED</name>
            <comment>The object won't use billboarding (default).</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>clearAnimation</name>
            <comment>Clears the animation for this object. The object ist no longer animated. Its mesh data will 
 be that of the last frame interpolation.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>COLLISION_CHECK_OTHERS</name>
            <comment>Other Object3Ds/rays/spheres/ellipsoids may collide with this object</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>disableVertexSharing</name>
            <comment>Disables the automatic vertex sharing that jPCT does for triangles added by addTriangle. 
 This can be useful if single polygons of the object are supposed to change their positions 
 independantly from the others (by using an IVertexController for example). It will hurt 
 performance though.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>addTriangle5</name>
            <comment>Adds a triangle to the object. The vertices have to be defined counter-clockwise because jPCT backface culls 
 them by default. One may also add them clockwise and call invert() afterwards to "invert" the order. This
 method takes a TextureInfo instead of the discrete u/v-coordinates and the textureID.
 -
 vert1 - the first vertex
 vert2 - the second vertex
 vert3 - the third vertex
 tInf - the TextureInfo</comment>
            <returntype>int</returntype>
            <parameter>
                <name>vert1</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>vert2</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>vert3</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>tInf</name>
                <type>com.threed.jpct.TextureInfo</type>
            </parameter>
        </method>
        <method>
            <name>addTriangle4</name>
            <comment>Adds a triangle to the object. The vertices have to be defined counter-clockwise because jPCT backface culls 
 them by default. One may also add them clockwise and call invert() afterwards to "invert" the order.
 -
 vert1 - the first vertex
 u - the u component of the texture position at the first vertex
 v - the v component of the texture position at the first vertex
 vert2 - the second vertex
 u2 - the u component of the texture position at the second vertex
 v2 - the v component of the texture position at the second vertex
 vert3 - the third vertex
 u3 - the u component of the texture position at the third vertex
 v3 - the v component of the texture position at the third vertex
 textureID - the ID of the texture as returned by TextureManager.getTextureID()
 sec - ?</comment>
            <returntype>int</returntype>
            <parameter>
                <name>vert1</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>u</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>vert2</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>u2</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v2</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>vert3</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>u3</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v3</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>textureID</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>sec</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>getTranslation2</name>
            <comment>Returns the translation of the object. The returned SimpleVector is the same one as the one given as
 parameter. This is useful to save the creation of an additional object. If null is given, a new one 
 will be created.
 -
 trns - the SimpleVector to fill and return</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>trns</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>addTriangle3</name>
            <comment>Adds a triangle to the object. Using the method, the sector will be set to undefined. The vertices have to be 
 defined counter-clockwise because jPCT backface culls them by default. One may also add them clockwise and call 
 invert() afterwards to "invert" the order.
 -
 vert1 - the first vertex
 u - the u component of the texture position at the first vertex
 v - the v component of the texture position at the first vertex
 vert2 - the second vertex
 u2 - the u component of the texture position at the second vertex
 v2 - the v component of the texture position at the second vertex
 vert3 - the third vertex
 u3 - the u component of the texture position at the third vertex
 v3 - the v component of the texture position at the third vertex
 textureID - the ID of the texture as returned by TextureManager.getTextureID()</comment>
            <returntype>int</returntype>
            <parameter>
                <name>vert1</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>u</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>vert2</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>u2</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v2</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>vert3</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>u3</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v3</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>textureID</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>addTriangle2</name>
            <comment>Adds a triangle to the object. Using the method, the texture of the object won't be set and the sector will be 
 set to undefined. The vertices have to be defined counter-clockwise because jPCT backface culls them by default. 
 One may also add them clockwise and call invert() afterwards to "invert" the order.
 -
 vert1 - the first vertex
 u - the u component of the texture position at the first vertex
 v - the v component of the texture position at the first vertex
 vert2 - the second vertex
 u2 - the u component of the texture position at the second vertex
 v2 - the v component of the texture position at the second vertex
 vert3 - the third vertex
 u3 - the u component of the texture position at the third vertex
 v3 - the v component of the texture position at the third vertex</comment>
            <returntype>int</returntype>
            <parameter>
                <name>vert1</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>u</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>vert2</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>u2</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v2</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>vert3</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>u3</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v3</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>compile3</name>
            <comment>Mainly needed to ease porting from the desktop version of jPCT. By default, jPCT-AE does this 
 call automatically, so usually there's no need to call this method directly.
 -
 dynamic - if the mesh dynamic?
 staticUV - does it use static uv-coordinates</comment>
            <returntype>void</returntype>
            <parameter>
                <name>dynamic</name>
                <type>boolean</type>
            </parameter>
            <parameter>
                <name>staticUV</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>rotateX</name>
            <comment>Rotates the object's rotation matrix around the x-axis by the given angle w (radian, counter 
 clockwise for positive values). This rotation is then applied to the object when it's rendered 
 the next time.
 -
 w - the angle by which should be rotated</comment>
            <returntype>void</returntype>
            <parameter>
                <name>w</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>checkForCollision</name>
            <comment>Checks if the current object collides with something when moving into a particular direction. This is just a 
 check, so no translations are being performed. A collision can only be detected with objects that are set to 
 COLLISION_CHECK_OTHERS. This method uses a ray-polygon collision detection.
 -
 dirVec - the direction vector (a unit vector)
 step - the length of the casted ray (a collision will only be detected of it takes place within this range)</comment>
            <returntype>int</returntype>
            <parameter>
                <name>dirVec</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>step</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>rotateZ</name>
            <comment>Rotates the object's rotation matrix around the z-axis by the given angle w (radian, counter 
 clockwise for positive values). This rotation is then applied to the object when it's rendered 
 the next time.
 -
 w - the angle by which should be rotated</comment>
            <returntype>void</returntype>
            <parameter>
                <name>w</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>OBJ_INVISIBLE</name>
            <comment>The object is invisible and won't be processed, rendered...nothing...</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>rotateY</name>
            <comment>Rotates the object's rotation matrix around the y-axis by the given angle w (radian, clockwise 
 for positive values). This rotation is then applied to the object when it's rendered the next time.
 -
 w - the angle by which should be rotated</comment>
            <returntype>void</returntype>
            <parameter>
                <name>w</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>COLLISION_NONE</name>
            <comment>Signals that no collision has been detected for this object</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>BILLBOARDING_ENABLED</name>
            <comment>The object will use billboarding (i.e. it always faces the camera)</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>align2</name>
            <comment>Aligns this object with another Object3D. This basically means that both objects will face into the 
 same direction after calling this method. Keep in mind that the rotation pivot influences the outcome
 too. This method works on the object's own rotation matrix only. It doesn't take transformations of 
 parent objects into account.
 -
 object - the object this object should be aligned with</comment>
            <returntype>void</returntype>
            <parameter>
                <name>object</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>enableCollisionListeners</name>
            <comment>(Re-)enables all collision listerner of this object.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>calcTextureWrap</name>
            <comment>"Wraps" a texture around the object. This may not look correct on every object, but it's a fast and easy 
 way to assign texture coordinates to objects that didn't have any. This kind of wrapping is basically a 
 kind of static environment mapping.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>calcTangentVectors</name>
            <comment>Tangent vectors are needed for some calculation in shaders. If you are using shaders 
 (i.e. OpenGL ES 2.0) and your shader needs these vectors and jPCT-AE wasn't able to 
 detect this (by searching for "attribute vec4 tangent" in the vertex shader, you might 
 want to trigger this calculation manually. By default, the calculation happens 
 automatically during build() if the need has been detected.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>ELLIPSOID_ALIGNED</name>
            <comment>The object's ellipsoid won't be transformed when performing collision 
 detection (default).</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>Initialize4</name>
            <comment>This constructor works similar to cloneObject() but it allows to extend Object3D and 
 still use the static methods from Loader/Primitives by adding a call to super(Object3D) 
 in the constructor of your class. Consider this to be a kind of "workaround" for the fact 
 that you can't extend a loaded (by Loader) or created (by Primitives) Object3D directly.
 -
 obj - the Object3D to construct this Object3D from
 reuseMesh - if true, the new object will use the same mesh</comment>
            <returntype>void</returntype>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
            <parameter>
                <name>reuseMesh</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>clearObject</name>
            <comment>Clears the object by removing all vertex/mesh information from it. This also affects objects 
 that have been cloned from this object, because they will lose their mesh-data too. Every 
 other property of the object stays intact.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Creates a new instance of Object3D. Usually, an object is created to be added 
 to some instance of World. You may also create dummy objects, that are just 
 "lending" there transformations to their child-objects, but this should be done
 by using createDummyObj().
 -
 maxTriangles - the maximum number of triangles for this object.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>maxTriangles</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>ENVMAP_ENABLED</name>
            <comment>Environment mapping is enabled.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>Initialize3</name>
            <comment>This constructor works similar to cloneObject() but it allows to extend Object3D and 
 still use the static methods from Loader/Primitives by adding a call to super(Object3D) 
 in the constructor of your class. Consider this to be a kind of "workaround" for the fact
 that you can't extend a loaded (by Loader) or created (by Primitives) Object3D directly.
 -
 obj - the Object3D to construct this Object3D from</comment>
            <returntype>void</returntype>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>rotateAxis</name>
            <comment>Rotates the object's rotation matrix around an arbitrary axis. The method is more powerful than the
 normal rotate-around-an-axis methods, but also a bit slower. The resulting matrix will be 
 orthonormalized to ensure numerical stability.
 -
 axis - a direction-vector pointing into the axis direction with the object's rotation pivot as position vector
 angle - the angle of the rotation</comment>
            <returntype>void</returntype>
            <parameter>
                <name>axis</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>Initialize1</name>
            <comment>Constructor for creating an Object3D out of indexed geometry in bulk form. 
 This can be useful to create an Object3D at once from data loaded by one's 
 own file loader.
 -
 coordinates - the coordinates [x1,y1,z1,x2,y2,z2,...]
 uvs - the texture coordinates [u1,v1,u2,v2,...]
 indices - the indices indexing the tuples/triples in the coordinate arrays
 textureId - the texture id. If not known, just use TextureManager.TEXTURE_NOTFOUND</comment>
            <returntype>void</returntype>
            <parameter>
                <name>coordinates</name>
                <type>float[]</type>
            </parameter>
            <parameter>
                <name>uvs</name>
                <type>float[]</type>
            </parameter>
            <parameter>
                <name>indices</name>
                <type>int[]</type>
            </parameter>
            <parameter>
                <name>textureId</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>COLLISION_CHECK_NONE</name>
            <comment>Don't perform any kind of collision detection for this object.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>mergeObjects</name>
            <comment>Static method that merges two objects into a third one. This should be done before calling 
 build() on any of these objects and it does not copy other properties of the object 
 (like rendering modes etc...). Merging objects is quite expensive in terms of memory usage.
 Merged objects are not compressed by default.
 -
 first - the first object to merge
 second - the second object to merge</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>first</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
            <parameter>
                <name>second</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>rayIntersectsAABB</name>
            <comment>Checks if a given ray intersects with the axis aligned bounding box (in object-space) of this object. This can 
 be useful to speed up some calculations. jPCT is using this method for faster collision detection. If the object
 doesn't have a bounding box for whatever reason, RAY_MISSES_BOX will be returned.
 -
 org - the position vector of the ray
 dr - the direction vector of the ray
 isNormalized - indicates, that dr is already normalized. So the method can spare another normalization.</comment>
            <returntype>float</returntype>
            <parameter>
                <name>org</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>dr</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>isNormalized</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>RAY_MISSES_BOX</name>
            <comment>Signals that a ray/box-intersection test has failed (the ray doesn't 
 intersect with the box)</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>align</name>
            <comment>Aligns this object with a Camera using the camera's backbuffer matrix. This means that the object 
 (i.e. its positive z-axis) will face into the same direction as the camera does. Calling this method 
 modifies the object's rotation matrix, but not its translation or origin matrix, i.e. the object is 
 facing into the camera's direction but it's not automatically placed at the camera's position. This
 has to be done "by hand" if required. Keep in mind that the rotation pivot of this object influences 
 the outcome too.
 -
 camera - the Camera the Object3D should be aligned with</comment>
            <returntype>void</returntype>
            <parameter>
                <name>camera</name>
                <type>com.threed.jpct.Camera</type>
            </parameter>
        </method>
        <method>
            <name>removeCollisionListener</name>
            <comment>Removes a collision listener from the list of listeners.
 -
 listener - the listener to remove</comment>
            <returntype>void</returntype>
            <parameter>
                <name>listener</name>
                <type>com.threed.jpct.CollisionListener</type>
            </parameter>
        </method>
        <method>
            <name>decoupleMesh</name>
            <comment>Decouples the current mesh from the object. This may be useful to assign another mesh to the 
 object without affecting cloned objects (from this object). Without the use of cloned objects, 
 the results of clearObject() and decoupleMesh() are the same (= an empty object).</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>strip</name>
            <comment>Frees some memory by stripping some data that isn't needed anymore unless you want to modify 
 the object afterwards by using a PolygonManager.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>CULLING_DISABLED</name>
            <comment>Backface culling won't be applied to this object.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>isEnvmapped</name>
            <comment>Returns if environment mapping is used or not.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>wasTargetOfLastCollision</name>
            <comment>True, if this object was a target of the last collision detection that took place (regardless of what kind it was). 
 Otherwise false. "A target" in this context means, that something has collided with this object, i.e. if one checks 
 object A for collision with other objects and it collides with an object B, B is the target and A is the source. 
 A collision is not automatically detected. One has to use one of the various ways jPCT offers for collision detection 
 to detect it.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>clearTranslation</name>
            <comment>Resets the current translation to the initial value, i.e. no translation at all.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>rotateMesh</name>
            <comment>Rotates the raw mesh data using the rotation matrix specified for this object. This rotation is applied directly 
 onto the mesh and therefor it's permanent. This could be useful for defining animation keyframes via object meshes
 or for altering objects in objectspace. Rotating a mesh forces the object's bounding box to be recalculated 
 afterwards (automatically done). The rotation matrix of the object won't be reset by this method.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>compile2</name>
            <comment>Mainly needed to ease porting from the desktop version of jPCT. By default, jPCT-AE does 
 this call automatically, so usually there's no need to call this method directly.
 -
 dynamic - if the mesh dynamic?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>dynamic</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>disableCollisionListeners</name>
            <comment>Disables all collision listeners of this object, so that none of them will be notified in case of a collision.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>calcNormals</name>
            <comment>Calculates the object's vertex normals by calculating the face normals of the adjacent polygons of each 
 vertex and averaging them. The normals are required for lighting and mapping, so they need to be calculated 
 for every object. Usually, this is already done by calling the object's build() method. (Respective by the
 loader for MD2-files).</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>calcCenter</name>
            <comment>Tries to calculate the center of the object using its mesh data. This is a very rough approach and while 
 it works very well on most objects, it may fail on others. This method sets both the center and the rotation
 pivot. This method is called by the build() method.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>translateMesh</name>
            <comment>Translates the raw mesh data using the translation and the origin matrix of this object. This 
 translation is applied directly onto the mesh and therefor it's permanent. This could be useful 
 for defining animation keyframes via object meshes or for altering objects in objectspace. 
 Translating a mesh forces the object's bounding box to be recalculated afterwards (automatically 
 done).</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>hasChild</name>
            <comment>Tests an object for being a child object of the current object. A child object inherits all 
 the transformations of its parent.
 -
 obj - the object that should be tested for being a child of this</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>LIGHTING_ALL_ENABLED</name>
            <comment>Indicates that all kinds of light (lightsources, ambient and additional 
 color) will be used on this object. This is default.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>wasVisible</name>
            <comment>Returns if the object was visible (or at least supposed to be) in the last frame. This can be useful 
 for some rough optimizations on the application level, but beware of assuming too much frame coherence. 
 The method doesn't take overdraw into account.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>cloneObject</name>
            <comment>Clones the current object. A cloned object A' of an object A is a copy of A at the point when the cloning 
 takes places. This means that A' inherits all rotations, translations and rendering properties from A. 
 However, A' and A are sharing the same mesh data (to save memory). This will cause A' to inherit all keyframe 
 animations from A and vice versa. Keep this in mind when cloning animated objects. Cloning an object is a 
 costly operation that should only be done when needed. If multiple copies of an object are required during 
 runtime, it may be helpful to create them at startup. This method also copies properties like lazy 
 transformation settings and similar, so take care to adjust afterwards on the cloned object if needed. Cloning 
 doesn't clone collision modes.</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
        </method>
        <method>
            <name>mergeAll</name>
            <comment>Merges all objects in the array into one large object. The array will be empty afterwards.
 -
 objs - the objects</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>objs</name>
                <type>com.threed.jpct.Object3D[]</type>
            </parameter>
        </method>
        <method>
            <name>invertCulling</name>
            <comment>Inverts culling order if set to true. This affects culling only, not the mesh itself (unlike invert()).
 -
 inv - invert the culling?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>inv</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>clearAdditionalColor</name>
            <comment>Removes additional color information form the object. Calling this method is equal to call 
 setAdditionalColor(Color.black).</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>clearRotation</name>
            <comment>Resets the current rotation to the initial value, i.e. no rotation at all. This will also reset the scale.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>checkForCollisionSpherical</name>
            <comment>Checks if the current object collides with something when moving into a particular direction. This is just a 
 check, so no translations are being performed. A collision can only be detected with objects that are set to 
 COLLISION_CHECK_OTHERS. This method uses a sphere-polygon collision detection.
 -
 translation - the translation the object should perform
 radius - the radius of the sphere (a collision will only be detected of it takes place within this radius)</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>translation</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>radius</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>calcMinDistance2</name>
            <comment>Returns the minimal distance to some polygon of the object from a particular position vector looking into a 
 specific direction. This version is a special purpose version of calcMinDistance() which only takes polygons 
 into consideration that have at least one vertex that is closer than ignoreIfLarger units to the position 
 vector. Can be useful to optimize calculations in situations where it is known how far away the polygon with 
 the minimal distance can be at max.
 -
 org - a SimpleVector containing the position vector
 dr - a SimpleVector containing the direction vector
 ignoreIfLarger - only polygons within this range will be taken into account</comment>
            <returntype>float</returntype>
            <parameter>
                <name>org</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>dr</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>ignoreIfLarger</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>calcMinDistance</name>
            <comment>Returns the minimal distance to some polygon of the object from a particular position vector looking into a 
 specific direction.
 -
 org - a SimpleVector containing the position vector
 dr - a SimpleVector containing the direction vector</comment>
            <returntype>float</returntype>
            <parameter>
                <name>org</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>dr</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>SHADING_GOURAUD</name>
            <comment>Indicates that gouraud shading should be used (default)</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>SPECULAR_ENABLED</name>
            <comment>Specular highLights will be calculated.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>COLLISION_DETECTION_NOT_OPTIMIZED</name>
            <comment>Disables (default) an automated optimization for collision detection in 
 case of problems with this optimization.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>translate2</name>
            <comment>Translates ("moves") the object in worldspace by modifying the translation matrix. The translation
 will be applied the next time the object is rendered.
 -
 x - the number of units the object should be translated parallel to the x axis
 y - the number of units the object should be translated parallel to the y axis
 z - the number of units the object should be translated parallel to the z axis</comment>
            <returntype>void</returntype>
            <parameter>
                <name>x</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>z</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>LIGHTING_NO_LIGHTS</name>
            <comment>Indicates that no lightsources will be taken into account to calculate 
 an object's lighting. Ambient light and the additional color will be used.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>CULLING_ENABLED</name>
            <comment>Backface culling will be applied to this object before rendering.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>ENVMAP_DISABLED</name>
            <comment>Environment mapping is disabled</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>removeParent</name>
            <comment>Removes an object from the parent-collection of this. The object itself won't be removed.
 -
 obj - the Object3D to remove</comment>
            <returntype>void</returntype>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>rayIntersectsAABB2</name>
            <comment>Checks if a given ray intersects with the axis aligned bounding box (in object-space) of this object. This can 
 be useful to speed up some calculations. jPCT is using this method for faster collision detection. If the object 
 doesn't have a bounding box for whatever reason, RAY_MISSES_BOX will be returned.
 -
 org - the position vector of the ray
 dr - the direction vector of the ray</comment>
            <returntype>float</returntype>
            <parameter>
                <name>org</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>dr</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>OBJ_VISIBLE</name>
            <comment>The object is visible.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>addCollisionListener</name>
            <comment>Adds a collision listener to this object. A collision listener gets notified in case of a collision with 
 or caused by this object.
 -
 listener - the listener</comment>
            <returntype>void</returntype>
            <parameter>
                <name>listener</name>
                <type>com.threed.jpct.CollisionListener</type>
            </parameter>
        </method>
        <method>
            <name>NO_OBJECT</name>
            <comment>The "ID" of an Object3D that doesn't exist. If a method that usually 
 returns an Object-ID returns this value, no appropiate Object3D has 
 been found.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>resetCollisionStatus</name>
            <comment>Sets the indicator that the object was a target of the last collision detection to false, i.e. the object won't 
 be recognized any longer as part of the collision. This is done automatically the next time a collision detection 
 method is being called.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>addTriangle</name>
            <comment>Adds a triangle to the object. Using the method, the texture of the object won't be set and the sector will be 
 set to undefined. Texture coordinates won't be set (= set to (0,0) for all vertices). The vertices have to be 
 defined counter-clockwise because jPCT backface culls them by default. One may also add them clockwise and call 
 invert() afterwards to "invert" the order.
 -
 vert1 - the first vertex
 vert2 - the second vertex
 vert3 - the third vertex</comment>
            <returntype>int</returntype>
            <parameter>
                <name>vert1</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>vert2</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>vert3</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>cullingIsInverted</name>
            <comment>Returns true, if inverted culling is used on this object. False otherwise.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>disableLazyTransformations</name>
            <comment>Disables "lazy transformations". This is the default setting for every new object.</comment>
            <returntype>void</returntype>
        </method>
        <property>
            <name>RotationPivot</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>pivot</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <comment>Returns the rotation pivot of the object</comment>
        </property>
        <property>
            <name>Translation</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the translation of the object (from its origin to its current position)</comment>
        </property>
        <property>
            <name>Virtualizer</name>
            <returntype>com.threed.jpct.Virtualizer</returntype>
            <parameter>
                <name>virtualizer</name>
                <type>com.threed.jpct.Virtualizer</type>
            </parameter>
            <comment>Returns the current Virtualizer. By default, none is set.</comment>
        </property>
        <property>
            <name>SortOffset</name>
            <parameter>
                <name>offset</name>
                <type>float</type>
            </parameter>
            <comment>Sets on offset for the z-Sorting. Usually this is not needed, but it could be helpful for 
 transparent objects that are sorted incorrectly otherwise.
 -
 offset - the offset</comment>
        </property>
        <property>
            <name>ZAxis</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the z-axis of the object. This is an imaginary axis useful for movement und rotations relative 
 to the object. This is based on the rotation matrix only. It doesn't take any parent objects into account.</comment>
        </property>
        <property>
            <name>Origin</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>origin</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <comment>Returns the origin of the object (as set by setOrigin()).</comment>
        </property>
        <property>
            <name>SpecularLighting</name>
            <parameter>
                <name>mode</name>
                <type>boolean</type>
            </parameter>
            <comment>Enables/Disables specular lighting for the object. The specular lighting pass is applied in 
 addition to ambient and diffuse lighting. Specular lighting may cause objects to look more 
 reflective and realistic. It requires some extra processing but usually it's just a matter 
 of taste if it will be used on a particular object or not. Specular lighting is disabled by 
 default.
 -
 mode - the specular mode</comment>
        </property>
        <property>
            <name>Texture</name>
            <parameter>
                <name>texname</name>
                <type>java.lang.String</type>
            </parameter>
            <comment>Sets the texture for the object. When using normal texturemapping, this texture is the only one used. With 
 environment mapping enabled, this texture is used as an environment map. With environment bumpmapping enabled, 
 this texture is pertubed by the bumpmap.
 -
 texname - the name of the texture as set in the TextureManager.addTexture()-method</comment>
        </property>
        <property>
            <name>WorldTransformation</name>
            <returntype>com.threed.jpct.Matrix</returntype>
            <comment>Returns the transformation matrix used to transform the object from objectspace into worldspace. Could be 
 useful for debugging purposes, but usually this information shouldn't be needed.</comment>
        </property>
        <property>
            <name>NextID</name>
            <returntype>int</returntype>
            <parameter>
                <name>next</name>
                <type>int</type>
            </parameter>
            <comment>Static method that returns the ID the next object will get. This is useful to know if 
 (and only if) you want to serialize your world, because this value isn't serialized by 
 default.</comment>
        </property>
        <property>
            <name>ID</name>
            <returntype>int</returntype>
            <comment>Returns the object's ID. The ID is automatically generated and set in the constructor. This ID is 
 used to manage the object once it has been added to an instance of World. In some cases, it could 
 be necessary to reset the ID.</comment>
        </property>
        <property>
            <name>AdditionalColor</name>
            <returntype>com.threed.jpct.RGBColor</returntype>
            <parameter>
                <name>col</name>
                <type>com.threed.jpct.RGBColor</type>
            </parameter>
            <comment>Returns the additional color.</comment>
        </property>
        <property>
            <name>Center</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>center</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <comment>Returns the center of the object (in object-space, i.e. unaffected by any transformation).</comment>
        </property>
        <property>
            <name>Scale</name>
            <returntype>float</returntype>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
            <comment>Returns the cumulated scale value for this object.</comment>
        </property>
        <property>
            <name>Parents</name>
            <returntype>com.threed.jpct.Object3D[]</returntype>
            <comment>Returns all parents of this Object3D in an array.</comment>
        </property>
        <property>
            <name>PolygonManager</name>
            <returntype>com.threed.jpct.PolygonManager</returntype>
            <comment>Returns the PolygonManager for this object. A PolygonManager can be used to access an object's polygons. 
 While you can obtain a PolygonManager from a stripped object, you can't safely modify the object.</comment>
        </property>
        <property>
            <name>LightCount</name>
            <returntype>int</returntype>
            <comment>Returns the number of lights that have an influence on this object. This is only valid during rendering, 
 i.e. only when called from within an IRenderHook.</comment>
        </property>
        <property>
            <name>TransformedCenter</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the center of the object in worldspace, i.e. after the object's current transformations 
 have been applied to it.</comment>
        </property>
        <property>
            <name>CollisionListeners</name>
            <returntype>java.util.Iterator</returntype>
            <comment>Returns the collision listeners of this object as an enumeration. The enumeration is empty if no listeners have 
 been assigned.</comment>
        </property>
        <property>
            <name>OriginMatrix</name>
            <returntype>com.threed.jpct.Matrix</returntype>
            <comment>Returns the object's origin-translation matrix. This matrix is a kind of static translation matrix for 
 the object used to initially place the object into worldspace. Without using child/parent-objects, there 
 is no difference between using the translation and the origin matrix, but only the former will be applied 
 to child objects of this object. It is advised to use the origin matrix to place the object into worldspace 
 once and to execute all further translations by using the translation matrix (or by using the translate()-method
 which already does this for you).</comment>
        </property>
        <property>
            <name>XAxis</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the x-axis of the object. This is an imaginary axis useful for movement und rotations relative 
 to the object. This is based on the rotation matrix only. It doesn't take any parent objects into account.</comment>
        </property>
        <property>
            <name>CollisionMode</name>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <comment>Sets if and how the object will respond to collisions. Setting mode to COLLISION_CHECK_NONE 
 (which is default) means, that the object can't be partner in a collision with other objects. 
 Setting it to COLLISION_CHECK_OTHERS means that other objects may collide with this object and 
 setting it to COLLISION_CHECK_SELF means, that the object itself may collide with other objects.
 The modes may be combined by using the or-operator | .
 -
 mode - The desired mode (COLLISION_CHECK_NONE, COLLISION_CHECK_OTHERS, 
 COLLISION_CHECK_SELF or combinations)</comment>
        </property>
        <property>
            <name>Culling</name>
            <returntype>boolean</returntype>
            <parameter>
                <name>mode</name>
                <type>boolean</type>
            </parameter>
            <comment>Returns the current culling mode.</comment>
        </property>
        <property>
            <name>TransparencyMode</name>
            <returntype>int</returntype>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <comment>Returns the current transparency mode.</comment>
        </property>
        <property>
            <name>Envmapped</name>
            <parameter>
                <name>mode</name>
                <type>boolean</type>
            </parameter>
            <comment>Enables/Disables environment mapping for the object. If enabled, the texturemap assigned to the 
 object will be used as a spherical environment map.
 -
 mode - the environment mapping mode</comment>
        </property>
        <property>
            <name>EllipsoidMode</name>
            <returntype>int</returntype>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <comment>Returns the current ellipsoid mode.</comment>
        </property>
        <property>
            <name>Visibility</name>
            <returntype>boolean</returntype>
            <parameter>
                <name>mode</name>
                <type>boolean</type>
            </parameter>
            <comment>Returns the current visibility state of the object.</comment>
        </property>
        <property>
            <name>Billboarding</name>
            <parameter>
                <name>mode</name>
                <type>boolean</type>
            </parameter>
            <comment>Enables/disables billboarding for this object. A billboarded object will ingore its own rotation 
 matrix and will always face the camera.
 -
 mode - the billboarding mode</comment>
        </property>
        <property>
            <name>TranslationMatrix</name>
            <returntype>com.threed.jpct.Matrix</returntype>
            <parameter>
                <name>mat</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
            <comment>Returns the object's current translation matrix.</comment>
        </property>
        <property>
            <name>YAxis</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the y-axis of the object. This is an imaginary axis useful for movement und rotations relative 
 to the object. This is based on the rotation matrix only. It doesn't take any parent objects into account.</comment>
        </property>
        <property>
            <name>OcTree</name>
            <returntype>com.threed.jpct.OcTree</returntype>
            <parameter>
                <name>arg0</name>
                <type>com.threed.jpct.OcTree</type>
            </parameter>
            <comment>Returns the OcTree assigned to this object or null, if none has been assigned.</comment>
        </property>
        <property>
            <name>Lighting</name>
            <returntype>int</returntype>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <comment>Gets the lighting mode.</comment>
        </property>
        <property>
            <name>MaxLights</name>
            <returntype>int</returntype>
            <parameter>
                <name>lightCount</name>
                <type>int</type>
            </parameter>
            <comment>Returns the maximum number of lights that should have an influence on this object. Default is 8.</comment>
        </property>
        <property>
            <name>CollisionOptimization</name>
            <parameter>
                <name>optimized</name>
                <type>boolean</type>
            </parameter>
            <comment>Sets an optimization for collision detection to be used/not used. This optimization may cause 
 problems on dynamically updated geometry from an animation or an IVertexController. Therefor, 
 it's disabled by default. Couldn't hurt to try it anyway...:-) This optimization affects collisions 
 WITH this object, not OF this object.
 -
 optimized - should the collision detection be optimized or not</comment>
        </property>
        <property>
            <name>Mesh</name>
            <returntype>com.threed.jpct.Mesh</returntype>
            <parameter>
                <name>mesh</name>
                <type>com.threed.jpct.Mesh</type>
            </parameter>
            <comment>Returns the current mesh of the object. This is useful for using an object's mesh data as keyframes for an 
 animation. The returned mesh can also be added to another object by using setMesh(). If you do so, both 
 objects will share the same instance of mesh. That isn't a problem as long as you don't want to modify the 
 mesh of one object without changing the other's. In this case, you should better use a copy of the mesh 
 obtained from Mesh.cloneMesh().</comment>
        </property>
        <property>
            <name>InverseWorldTransformation</name>
            <returntype>com.threed.jpct.Matrix</returntype>
            <comment>getInverseWorldTransformation ?</comment>
        </property>
        <property>
            <name>FixedPointMode</name>
            <parameter>
                <name>useFixedPoint</name>
                <type>boolean</type>
            </parameter>
            <comment>If set to true, some operations will be using fixed point instead of floating point. This is less
 accurate and may cause problems with large coordinates, but is usually faster. Default is true.
 -
 useFixedPoint - use it?</comment>
        </property>
        <property>
            <name>Shader</name>
            <returntype>com.threed.jpct.GLSLShader</returntype>
            <parameter>
                <name>shader</name>
                <type>com.threed.jpct.GLSLShader</type>
            </parameter>
            <comment>Returns the shader, if another one than the default shader is set. This is only valid when using OpenGL ES 2.0.</comment>
        </property>
        <property>
            <name>AnimationSequence</name>
            <returntype>com.threed.jpct.Animation</returntype>
            <parameter>
                <name>anim</name>
                <type>com.threed.jpct.Animation</type>
            </parameter>
            <comment>Returns the animation sequence.</comment>
        </property>
        <property>
            <name>Transparency</name>
            <returntype>int</returntype>
            <parameter>
                <name>trans</name>
                <type>int</type>
            </parameter>
            <comment>Returns the current tranparency setting.</comment>
        </property>
        <property>
            <name>ShadingMode</name>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <comment>jPCT always uses gouraud shading and that can't be disabled. Anyway, with this method it's possible 
 to enable a kind of faked flat shading. It will look like flat shading, but it isn't any faster than 
 gouraud. It may even be slower, because triangle strips and some other optimizations jPCT can apply 
 are disabled when using faked flat shading.
 -
 mode - the shading mode</comment>
        </property>
        <property>
            <name>Texture2</name>
            <parameter>
                <name>tInf</name>
                <type>com.threed.jpct.TextureInfo</type>
            </parameter>
            <comment>Sets the texture for the object via an instance of TextureInfo. Texture coordinates for all layers are taken 
 from the coordinates defined for the base layer of the Object3D, i.e. u/v coordinates given to this TextureInfo 
 will be ignored.
 -
 tInf - the TextureInfo</comment>
        </property>
        <property>
            <name>RenderHook</name>
            <returntype>com.threed.jpct.IRenderHook</returntype>
            <parameter>
                <name>hook</name>
                <type>com.threed.jpct.IRenderHook</type>
            </parameter>
            <comment>Returns the render hook or null, if none has been set.</comment>
        </property>
        <property>
            <name>Name</name>
            <returntype>java.lang.String</returntype>
            <parameter>
                <name>n</name>
                <type>java.lang.String</type>
            </parameter>
            <comment>Returns the name of the object. By default, this is set to "object" plus the object's internal ID. 
 It may be overwritten using setName().</comment>
        </property>
        <property>
            <name>TextureMatrix</name>
            <returntype>com.threed.jpct.Matrix</returntype>
            <parameter>
                <name>mat</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
            <comment>Returns the current texture matrix of null if none is set.</comment>
        </property>
        <property>
            <name>UserObject</name>
            <returntype>java.lang.Object</returntype>
            <parameter>
                <name>obj</name>
                <type>java.lang.Object</type>
            </parameter>
            <comment>Return the user defined object.</comment>
        </property>
        <property>
            <name>RotationMatrix</name>
            <returntype>com.threed.jpct.Matrix</returntype>
            <parameter>
                <name>mat</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
            <comment>Returns the object's current rotation matrix.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JNVDepthConfigChooser</name>
        <shortname>JpctNVDepthConfigChooser</shortname>
        <objectwrapper>com.threed.jpct.util.NVDepthConfigChooser</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Creates a new NVDepthConfigChooser
 -
 view - the GLSurfaceView</comment>
            <returntype>void</returntype>
            <parameter>
                <name>view</name>
                <type>android.opengl.GLSurfaceView</type>
            </parameter>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Creates a new NVDepthConfigChooser with optional alpha for the framebuffer.
 -
 view - the GLSurfaceView
 withAlpha - alpha channel (for transparent framebuffers)?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>view</name>
                <type>android.opengl.GLSurfaceView</type>
            </parameter>
            <parameter>
                <name>withAlpha</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>chooseConfig</name>
            <comment>chooseConfig
 -
 egl - EGL10
 display - EGLDisplay</comment>
            <returntype>javax.microedition.khronos.egl.EGLConfig</returntype>
            <parameter>
                <name>egl</name>
                <type>javax.microedition.khronos.egl.EGL10</type>
            </parameter>
            <parameter>
                <name>display</name>
                <type>javax.microedition.khronos.egl.EGLDisplay</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JNPOTTexture</name>
        <shortname>JpctNPOTTexture</shortname>
        <objectwrapper>com.threed.jpct.NPOTTexture</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Creates a new NPOT texture.
 -
 width - the width of the texture.
 height - the height of the texture.
 col - the color. Can be null for render targets.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>width</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>height</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>col</name>
                <type>com.threed.jpct.RGBColor</type>
            </parameter>
        </method>
        <method>
            <name>enable4bpp</name>
            <comment>Makes jPCT converting this texture to use 4 bits per pixel/alpha (respectively 5/1 
 without a dedicated alpha channel) instead of 8, i.e. use 16 bit textures. Default 
 is false unless you call Texture.defaultTo4bpp(true);
 -
 doit - should we?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>doit</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>removeAlpha</name>
            <comment>Removes any alpha information from a texture.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>defaultTo4bpp</name>
            <comment>Static method to set the textures' default depth to 4bpp (respectively 5bpp without a 
 dedicated alpha channel). This doesn't affect the Texture instances themselves but the 
 data uploaded to the graphics card.
 -
 doit - should 4bpp be the default?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>doit</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>add</name>
            <comment>Adds a textures color (and alpha) information to this one.
 -
 ta - the texture whose color should be added
 weight - the weight of the second texture's data. May be even negative.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>ta</name>
                <type>com.threed.jpct.Texture</type>
            </parameter>
            <parameter>
                <name>weight</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>applyEffect</name>
            <comment>Applies the effect to the texture. Depending on the implementation of the effect, 
 this can be slow.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>isEnabled</name>
            <comment>Returns if the texture is enabled or not. A disabled texture won't show up when used on 
 any texture stage except the first one.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>compress</name>
            <comment>Compresses the texture so that is uses less main memory. This doesn't effect the memory 
 used inside the gpu. Compressed textures require some more time to upload. If the saved 
 space is less than 5% of the original size, the texture won't be compressed.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>keepPixelData</name>
            <comment>Should a texture's pixels be kept even when the texture has been uploaded to the GPU? 
 Default is false.
 -
 keepData - should they?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>keepData</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>defaultToKeepPixels</name>
            <comment>Static method to set the textures' default behaviour for keeping the pixel data after 
 uploading to the gpu. Default is true.
 -
 doit -</comment>
            <returntype>void</returntype>
            <parameter>
                <name>doit</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>defaultToMipmapping</name>
            <comment>Static method to make all textures use mipmaps by default. Default setting is false.
 -
 doit - should mipmapping be the default?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>doit</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>removeEffect</name>
            <comment>Removes an ITextureEffect from the Texture</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>Enabled</name>
            <parameter>
                <name>isEnabled</name>
                <type>boolean</type>
            </parameter>
            <comment>Sets the texture to enable/disabled. A disabled texture won't show up when used on any 
 texture stage except the first one. Default it true.
 -
 isEnabled - is it enabled?</comment>
        </property>
        <property>
            <name>Mipmap</name>
            <parameter>
                <name>mipmap</name>
                <type>boolean</type>
            </parameter>
            <comment>Enabled/Disables mip map setting for a texture. Default is true.
 -
 mipmap - true, if there's no override. false means no mip mapping/trilinear for this texture</comment>
        </property>
        <property>
            <name>Filtering</name>
            <parameter>
                <name>filter</name>
                <type>boolean</type>
            </parameter>
            <comment>Sets the bilinear filtering state on textures. Setting this to false forces jPCT to use 
 a pick nearest on the textures. This may also affect mip mapping.
 -
 filter - the mode, true for bilinear, false for pick nearest</comment>
        </property>
        <property>
            <name>ArraySize</name>
            <returntype>int</returntype>
            <comment>Returns the size of the texture array.</comment>
        </property>
        <property>
            <name>Clamping</name>
            <parameter>
                <name>clamping</name>
                <type>boolean</type>
            </parameter>
            <comment>Set texture coordinate to clamping or wrapping/repeating. Calling this on an already 
 uploaded texture forces a new texture upload to the graphics card.
 -
 clamping - clamping or wrapping/repeating?</comment>
        </property>
        <property>
            <name>Height</name>
            <returntype>int</returntype>
            <comment>Returns the height of the texture in pixels.</comment>
        </property>
        <property>
            <name>Effect</name>
            <parameter>
                <name>effect</name>
                <type>com.threed.jpct.ITextureEffect</type>
            </parameter>
            <comment>Sets an effect for this texture. The effect is an implementation of ITextureEffect.
 -
 effect - the effect</comment>
        </property>
        <property>
            <name>AsShadowMap</name>
            <parameter>
                <name>isShadowMap</name>
                <type>boolean</type>
            </parameter>
            <comment>Marks this texture as a shadow map. This only affects the OpenGL ES 2.0 mode.
 -
 isShadowMap - is it a shadow map or not?</comment>
        </property>
        <property>
            <name>TextureCompression</name>
            <parameter>
                <name>enabled</name>
                <type>boolean</type>
            </parameter>
            <comment>Enables ETC1-texture compression if available on the platform. If not, jPCT-AE will fall 
 back to normal textures. This is an experimental feature for now. The usual restrictions 
 for ETC1 apply.
 -
 enabled - enable ETC1 texture compression</comment>
        </property>
        <property>
            <name>DepthBuffer</name>
            <returntype>com.threed.jpct.DepthBuffer</returntype>
            <parameter>
                <name>depthBuffer</name>
                <type>com.threed.jpct.DepthBuffer</type>
            </parameter>
            <comment>?</comment>
        </property>
        <property>
            <name>Width</name>
            <returntype>int</returntype>
            <comment>Returns the width of the texture in pixels.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JMultiTouch.JMotionEvent</name>
        <shortname>JpctMotionEvent</shortname>
        <owner>process</owner>
        <method>
            <name>getPressure</name>
            <comment>Returns the current pressure of this event for the given pointer 
 index.</comment>
            <returntype>float</returntype>
            <parameter>
                <name>pointerIndex</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>getY</name>
            <comment>Returns the Y coordinate of this event for the given pointer 
 index.</comment>
            <returntype>float</returntype>
            <parameter>
                <name>pointerIndex</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>getX</name>
            <comment>Returns the X coordinate of this event for the given pointer
 index.</comment>
            <returntype>float</returntype>
            <parameter>
                <name>pointerIndex</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>getPointerId</name>
            <comment>Return the pointer identifier associated with a particular
 pointer data index in this event.</comment>
            <returntype>int</returntype>
            <parameter>
                <name>pointerIndex</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>getSize</name>
            <comment>Returns a scaled value of the approximate size for the 
 given pointer index (use getPointerId(int) to find the 
 pointer identifier for this index).</comment>
            <returntype>float</returntype>
            <parameter>
                <name>pointerIndex</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>findPointerIndex</name>
            <comment>Given a pointer identifier, find the index of its data in 
 the event.</comment>
            <returntype>int</returntype>
            <parameter>
                <name>pointerId</name>
                <type>int</type>
            </parameter>
        </method>
        <property>
            <name>DownTime</name>
            <returntype>long</returntype>
            <comment>Returns the time (in ms) when the user originally pressed 
 down to start a stream of position events.</comment>
        </property>
        <property>
            <name>Action</name>
            <returntype>int</returntype>
            <comment>Returns the kind of action being performed.</comment>
        </property>
        <property>
            <name>EventTime</name>
            <returntype>long</returntype>
            <comment>Retrieve the time this event occurred, in the uptimeMillis() 
 timebase.</comment>
        </property>
        <property>
            <name>ActionMasked</name>
            <returntype>int</returntype>
            <comment>Returns the masked action being performed, 
 without pointer index information.</comment>
        </property>
        <property>
            <name>PointerCount</name>
            <returntype>int</returntype>
            <comment>The number of pointers of data contained in this event.</comment>
        </property>
        <property>
            <name>RawY</name>
            <returntype>float</returntype>
            <comment>Returns the original raw Y coordinate of this event.</comment>
        </property>
        <property>
            <name>RawX</name>
            <returntype>float</returntype>
            <comment>Returns the original raw X coordinate of this event.</comment>
        </property>
        <property>
            <name>Y</name>
            <returntype>float</returntype>
            <comment>For the first/primary/only pointer index (maybean arbitrary 
 pointer identifier).</comment>
        </property>
        <property>
            <name>X</name>
            <returntype>float</returntype>
            <comment>For the first/primary/only pointer index (maybe an arbitrary 
 pointer identifier).</comment>
        </property>
        <property>
            <name>ActionIndex</name>
            <returntype>int</returntype>
            <comment>For ACTION_POINTER_DOWN or ACTION_POINTER_UP
 as returned by getActionMasked(), this returns the 
 associated pointer index, Otherwise it's returning 
 always 0.</comment>
        </property>
        <field>
            <name>ACTION_POINTER_DOWN</name>
            <comment>Constant = 5 for getActionMasked(): A non-primary 
 pointer has gone down.</comment>
            <returntype>int</returntype>
        </field>
        <field>
            <name>ACTION_MASK</name>
            <comment>bit mask = 255 of the parts of the action code that are the 
 action itself.</comment>
            <returntype>int</returntype>
        </field>
        <field>
            <name>ACTION_POINTER_INDEX_SHIFT</name>
            <comment>bit shift = 8 for the action bits holding the pointer 
 index as defined by ACTION_POINTER_INDEX_MASK.</comment>
            <returntype>int</returntype>
        </field>
        <field>
            <name>ACTION_DOWN</name>
            <comment>Constant = 0 for getActionMasked(): Apressed gesture 
 has started, the motion contains the initial starting 
 location.</comment>
            <returntype>int</returntype>
        </field>
        <field>
            <name>ACTION_POINTER_UP</name>
            <comment>Constant = 6 for getActionMasked(): A non-primary 
 pointer has gone up.</comment>
            <returntype>int</returntype>
        </field>
        <field>
            <name>ACTION_UP</name>
            <comment>Constant = 1 for getActionMasked(): A pressed gesture has
 finished, the motion contains the final release location 
 as well as any intermediate points since the last down 
 or move event.</comment>
            <returntype>int</returntype>
        </field>
        <field>
            <name>ACTION_MOVE</name>
            <comment>Constant = 2 for getActionMasked(): Achange has 
 happened during a press gesture (between 
 ACTION_DOWN and ACTION_UP).</comment>
            <returntype>int</returntype>
        </field>
        <field>
            <name>ACTION_POINTER_INDEX_MASK</name>
            <comment>bits = 65280 in the action code that represent a pointer 
 index, used with ACTION_POINTER_DOWN and 
 ACTION_POINTER_UP.</comment>
            <returntype>int</returntype>
        </field>
        <field>
            <name>ACTION_CANCEL</name>
            <comment>Constant = 3 for getActionMasked(): The current gesture 
 has been aborted.</comment>
            <returntype>int</returntype>
        </field>
        <field>
            <name>INVALID_POINTER_ID</name>
            <comment>Constant for getActionMasked(): The current gesture 
 has been aborted.</comment>
            <returntype>int</returntype>
        </field>
    </class>
    <class>
        <name>jpct.ae.wrapper.JMultiTouch.JScaleEvent</name>
        <shortname>JpctScaleEvent</shortname>
        <comment>---------------------------------------------------------------------------------------
 										JScaleEvent
 Detects scaling transformation gestures using the supplied MotionEvents. The callback 
 will notify users when a particular gesture event has occurred. This class should only 
 be used with MotionEvents reported via touch.
----------------------------------------------------------------------------------------</comment>
        <owner>process</owner>
        <method>
            <name>isInProgress</name>
            <comment>Returns true if a scale gesture is in progress.</comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>PreviousSpan</name>
            <returntype>float</returntype>
            <comment>Return the previous average distance between each of 
 the pointers forming the gesture in progress through 
 the focal point.</comment>
        </property>
        <property>
            <name>CurrentSpan</name>
            <returntype>float</returntype>
            <comment>Return the average distance between each of 
 the pointers forming the gesture in progress 
 through the focal point.</comment>
        </property>
        <property>
            <name>EventTime</name>
            <returntype>long</returntype>
            <comment>Return the event time of the current event 
 being processed.</comment>
        </property>
        <property>
            <name>TimeDelta</name>
            <returntype>long</returntype>
            <comment>Return the time difference in milliseconds between the 
 previous accepted scaling event and the current scaling 
 event.</comment>
        </property>
        <property>
            <name>ScaleFactor</name>
            <returntype>float</returntype>
            <comment>Return the scaling factor from the previous scale event
 to the current event.</comment>
        </property>
        <property>
            <name>FocusX</name>
            <returntype>float</returntype>
            <comment>Get the X coordinate of the current gesture's 
 focal point.</comment>
        </property>
        <property>
            <name>FocusY</name>
            <returntype>float</returntype>
            <comment>Get the Y coordinate of the current gesture's 
 focal point.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JMultiTouch.JGestureEvent</name>
        <shortname>JpctGestureEvent</shortname>
        <owner>process</owner>
        <method>
            <name>FlingVelocityX</name>
            <comment>The velocity of this fling measured in pixels 
 per second along the x axis.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>ScrollDistanceX</name>
            <comment>The distance along the X axis that has been 
 scrolled since the last call to onScroll.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>ScrollDistanceY</name>
            <comment>The distance along the Y axis that has been 
 scrolled since the last call to onScroll.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>onSingleTapUp</name>
            <comment>Notified when a tap occurs with the up MotionEvent
 that triggered it.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>onFling</name>
            <comment>Notified of a fling event when it occurs with the 
 initial on down MotionEvent and the matching up 
 MotionEvent.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>isInProgress</name>
            <comment>Returns true if a scale gesture is in progress.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>onDown</name>
            <comment>Notified when a tap occurs with the down 
 MotionEvent that triggered it. This will be 
 triggered immediately for every down event.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>onShowPress</name>
            <comment>The user has performed a down MotionEvent and not 
 performed a move or up yet.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>onDoubleTapEvent</name>
            <comment>Notified when an event within a double-tap gesture
 occurs, including the down, move, and up events.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>onDoubleTap</name>
            <comment>Notified when a double-tap occurs.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>FlingVelocityY</name>
            <comment>The velocity of this fling measured in pixels 
 per second along the y axis.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>onLongPress</name>
            <comment>Notified when a long press occurs with the initial 
 on down MotionEvent that trigged it.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>onScroll</name>
            <comment>Notified when a scroll occurs with the initial on 
 down MotionEvent and the current move MotionEvent.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>onSingleTapConfirmed</name>
            <comment>Notified when a single-tap occurs. Unlike onSingleTapUp,
 this will only be called after the detector is confident 
 that the user's first tap is not followed by a second tap 
 leading to a double-tap gesture.</comment>
            <returntype>boolean</returntype>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JMesh</name>
        <shortname>JpctMesh</shortname>
        <objectwrapper>com.threed.jpct.Mesh</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Initialize Mesh
 -
 object3D - the object you want to assign its mesh</comment>
            <returntype>void</returntype>
            <parameter>
                <name>object3D</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>SERIALIZE_LOW_PRECISION</name>
            <comment>float data will be saved as 16 bit precision. 
 on the average ~0.3 percent of precision will be lost</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>DONT_COMPRESS</name>
            <comment>The mesh won't be compressed.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>COMPRESS</name>
            <comment>The mesh will be compressed.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>strip</name>
            <comment>Removes triangle information from this mesh. This is useful to save some memory for 
 meshes that are used for keyframing only (triangle information are not needed in 
 that case). For any other meshes: Don't call this method. It will break your mesh!</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>cloneMesh</name>
            <comment>Returns a copy of this mesh. A copy of a mesh can be used to take a mesh from an 
 existing object and modify it without modifying the source mesh. With this, you 
 can also use meshes from existing objects (not only temporary ones) as meshes for 
 a keyframe animation [like: Animation.addKeyFrame(obj.getMesh().cloneMesh(...))]. 
 Cloning a compressed mesh without letting cloneMesh compress it again will result 
 in an uncompressed one (eats up more memory, but triangles may be added to such a
 mesh again).
 -
 compressed - indicates if compress() should by called after cloning the mesh or not</comment>
            <returntype>com.threed.jpct.Mesh</returntype>
            <parameter>
                <name>compressed</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>setVertexController</name>
            <comment>Sets the VertexController for this Mesh. A VertexController is the only way
 for an application to modify the vertex data of jPCT's meshes after build-time. 
 Usually, a custom VertexController extend the GenericVertexController the API 
 provides. An instance can only be assigned to one mesh at a time. This mesh 
 should include vertex normals, i.e. it has to belong to an object for which 
 build() has been called already. If that's not the case, jPCT will print out 
 a warning message.
 -
 controller - the controller
 modify - the mode, i.e. if the modifications are cumulative or not</comment>
            <returntype>void</returntype>
            <parameter>
                <name>controller</name>
                <type>com.threed.jpct.IVertexController</type>
            </parameter>
            <parameter>
                <name>modify</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>applyVertexController</name>
            <comment>Executes the apply() method of the assigned VertexController and updates the mesh's 
 vertex data with the new values generated by the controller.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>isLocked</name>
            <comment>Returns if this mesh has been locked or not!</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>removeVertexController</name>
            <comment>Removes the VertexController from this mesh. When doing so, the controller's 
 destroy() method will be called.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>SERIALIZE_ALL</name>
            <comment>normal serialization (default).</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Initialize Mesh
 -
 mesh - the mesh you want to assign (you can get it by cloneMesh)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>mesh</name>
                <type>com.threed.jpct.Mesh</type>
            </parameter>
        </method>
        <method>
            <name>forceCompress</name>
            <comment>Compresses the mesh by removing unused information from it. When creating a 
 mesh, it is usually not known how many unique vertices it may contain, so space 
 is reserved for the extreme case that no vertex-sharing is possible within this
 mesh (the vertex sharing is something that jPCT automatically takes care of). 
 The more vertices are sharable between the triangles of the mesh, the more space
 remains unused. compress() frees this space at the cost that no additional 
 vertices can be added to the mesh after compressing it. If one is sure that this 
 is not required, compressing a mesh can be helpful to save memory. Meshes of 
 loaded MD2- and 3DS-models are compressed by default.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>SERIALIZE_VERTICES_ONLY</name>
            <comment>Normals will not be serialized and will have to be 
 recalculated during deserialization. This saves a lot 
 of space but increases load time.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>TriangleCount</name>
            <returntype>int</returntype>
            <comment>The number of triangles for this mesh.</comment>
        </property>
        <property>
            <name>VertexCount</name>
            <returntype>int</returntype>
            <comment>Returns the number of vertices this mesh consists of</comment>
        </property>
        <property>
            <name>BoundingBox</name>
            <returntype>float[]</returntype>
            <comment>Returns the bounding box in object space of this mesh in a float array. Format is 
 minX, maxX, minY, maxY, minZ, maxZ. Calculation is done everytime this method is 
 being called, so don't call it without need.</comment>
        </property>
        <property>
            <name>SerializeMethod</name>
            <parameter>
                <name>method</name>
                <type>int</type>
            </parameter>
            <comment>Sets the serialization method. Can be used to decrease the size of a serialized
 Mesh at the cost of loading speed and/or accuracy.
 -
 method - Either SERIALIZE_ALL, DONT_SERIALIZE_NORMALS or SERIALIZE_LOW_PRECISION. 
 Methods can be combined by using the or-operator.</comment>
        </property>
        <property>
            <name>Locked</name>
            <parameter>
                <name>locked</name>
                <type>boolean</type>
            </parameter>
            <comment>Locks an object. A locked mesh can't and won't be stripped even if you call the 
 corresponding methods. This can be used to strip Object3Ds that are sharing Meshes.
 locked - should it be locked?</comment>
        </property>
        <property>
            <name>UniqueVertexCount</name>
            <returntype>int</returntype>
            <comment>Returns the number of unique vertices. Unlike getVertexCount(), this number takes 
 into account that vertices are shared between triangles whenever possible to lower 
 geometry processing time. jPCT does only transform as many vertices as this number 
 indicates.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JMemoryHelper</name>
        <shortname>JpctMemoryHelper</shortname>
        <objectwrapper>com.threed.jpct.util.MemoryHelper</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Initialize MemoryHelper</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>compact</name>
            <comment>Tries to free some memory but forcing gc and finalization. Write current 
 memory usage to the log. This can be used to trigger some gc work that 
 might otherwise interrupt the application causing an animation to stutter 
 or similar. However, this method can't avoid that...it just increases the 
 chance that won't happen or at least not that often.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>printMemory</name>
            <comment>Prints current memory usage into the log.</comment>
            <returntype>void</returntype>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JMatrix</name>
        <shortname>JpctMatrix</shortname>
        <objectwrapper>com.threed.jpct.Matrix</objectwrapper>
        <owner>process</owner>
        <method>
            <name>matMul</name>
            <comment>Multiplies this matrix with another one.
 -
 maty - the matrix to multiply with</comment>
            <returntype>void</returntype>
            <parameter>
                <name>maty</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
        </method>
        <method>
            <name>getZAxis</name>
            <comment>Returns the z-axis this matrix would represent when viewed as a rotation 
 matrix. This method fills the given SimpleVector in addition to returning 
 it.
 -
 toFill - the vector to fill</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>toFill</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>transpose</name>
            <comment>Calculates the transposed matrix of this matrix.</comment>
            <returntype>com.threed.jpct.Matrix</returntype>
        </method>
        <method>
            <name>setRow</name>
            <comment>Inject values directly into a matrix' row.
 -
 row - thw row
 v1 - the first value
 v2 - the second value
 v3 - the third value
 v4 - the fourth value</comment>
            <returntype>void</returntype>
            <parameter>
                <name>row</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>v1</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v2</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v3</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v4</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>set</name>
            <comment>Injects a value directly into the matrix at a position.
 -
 row - the row
 col - the column
 value - the value to set</comment>
            <returntype>void</returntype>
            <parameter>
                <name>row</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>col</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>value</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>rotateX</name>
            <comment>Rotates the matrix around the X-axis (counter clockwise for positive w).
 -
 w - the rotation angle</comment>
            <returntype>void</returntype>
            <parameter>
                <name>w</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>rotateZ</name>
            <comment>Rotates the matrix around the Z-axis (counter clockwise for positive w).
 -
 w - the rotation angle</comment>
            <returntype>void</returntype>
            <parameter>
                <name>w</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>rotateY</name>
            <comment>Rotates the matrix around the Y-axis (clockwise for positive w).
 -
 w - the rotation angle</comment>
            <returntype>void</returntype>
            <parameter>
                <name>w</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>invert</name>
            <comment>Calculates the inverse of this matrix.</comment>
            <returntype>com.threed.jpct.Matrix</returntype>
        </method>
        <method>
            <name>isIdentity</name>
            <comment>Returns true, if this matrix is the identity matrix.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>interpolate</name>
            <comment>Fills the matrix with data interpolated between the source and the destination 
 matrix. The interpolation is (source*(1-weight)+dest*weigth), so it's a simple 
 linear interpolation. The interpolated matrix is orthonormal. However, it's 
 possible that the interpolation will result in a NaN-Matrix, if the matrices 
 to interpolate are too different from each other. Keep that in mind...
 -
 source - the source matrix
 dest - the destination matrix
 weight - the weight of the destination matrix (0-1)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>source</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
            <parameter>
                <name>dest</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
            <parameter>
                <name>weight</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>setOrientation</name>
            <comment>Sets the orientation of a rotation matrix by giving a direction and an up-vector.
 -
 dir - the direction
 up - the up-vector</comment>
            <returntype>void</returntype>
            <parameter>
                <name>dir</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>up</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Creates a matrix from a given one. The new matrix will bi initialized with 
 the same values that the source matrix has.
 -
 m - the source matrix</comment>
            <returntype>void</returntype>
            <parameter>
                <name>m</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
        </method>
        <method>
            <name>rotateAxis</name>
            <comment>Rotates the matrix around an arbitrary axis. The method is more powerful than
 the normal rotate-around-an-axis methods, but also a bit slower. The resulting 
 matrix will be orthonormalized to ensure numerical accuracy.
 -
 axis - a direction-vector pointing into the axis direction
 angle - the angle of the rotation</comment>
            <returntype>void</returntype>
            <parameter>
                <name>axis</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>setColumn</name>
            <comment>Inject values directly into a matrix' column.
 -
 col - thw column
 v1 - the first value
 v2 - the second value
 v3 - the third value
 v4 - the fourth value</comment>
            <returntype>void</returntype>
            <parameter>
                <name>col</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>v1</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v2</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v3</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>v4</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getYAxis</name>
            <comment>Returns the y-axis this matrix would represent when viewed as a rotation 
 matrix. This method fills the given SimpleVector in addition to returning
 it.
 -
 toFill - the vector to fill</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>toFill</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>Initialize</name>
            <comment>Initialize Matrix</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>cloneMatrix</name>
            <comment>Creates a copy of this matrix.</comment>
            <returntype>com.threed.jpct.Matrix</returntype>
        </method>
        <method>
            <name>orthonormalize</name>
            <comment>Orthonormalizes a matrix using the Gramm-Schmidt orthonormalization 
 algorithm. This can be useful for rotation matrices to ensure that 
 they stay orthonormal over time (i.e. after a lot of rotations have 
 been applied to them). jPCT doesn't do this automatically, because 
 there seems to be no need for it at the moment. But if there ever 
 is, here is the method for doing it...</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>get</name>
            <comment>Returns the value at a position in the matrix.
 -
 row - the row
 col - the column</comment>
            <returntype>float</returntype>
            <parameter>
                <name>row</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>col</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>equals</name>
            <comment>Overrides equals in class java.lang.Object</comment>
            <returntype>boolean</returntype>
            <parameter>
                <name>obj</name>
                <type>java.lang.Object</type>
            </parameter>
        </method>
        <method>
            <name>translate2</name>
            <comment>Applies a translation to this matrix. This implementation should help to avoid 
 the unnecessary creation of a SimpleVector if the coordinates already exist as
 three seperated ones.
 -
 x - the x component of the translation
 y - the y component of the translation
 z - the z component of the translation</comment>
            <returntype>void</returntype>
            <parameter>
                <name>x</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>z</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>invert3x3_2</name>
            <comment>Calculates the inverse of this matrix as if this matrix would be a 3x3 
 one (instead of the 4x4 it actually is). This can be useful to invert 
 matrices that are rotation matrices only, because they usually can be 
 treated as 3x3 and it's much faster to do it this way than to use the
 normal invert()-method. In case of doubt, one may be better off using 
 the normal invert()-method though. Fills the result into the given 
 matrix (which will be returned in addition).
 -
 toFill - the matrix to fill</comment>
            <returntype>com.threed.jpct.Matrix</returntype>
            <parameter>
                <name>toFill</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
        </method>
        <method>
            <name>setIdentity</name>
            <comment>(Re-)sets this matrix to the identity matrix.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>scalarMul</name>
            <comment>Multiplies this matrix with a scalar (the left upper 3x3 part only).
 -
 scalar - the scalar to multiply with</comment>
            <returntype>void</returntype>
            <parameter>
                <name>scalar</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>invert3x3</name>
            <comment>Calculates the inverse of this matrix as if this matrix would be a 3x3 
 one (instead of the 4x4 it actually is). This can be useful to invert 
 matrices that are rotation matrices only, because they usually can be 
 treated as 3x3 and it's much faster to do it this way than to use the 
 normal invert()-method. In case of doubt, one may be better off using 
 the normal invert()-method though.</comment>
            <returntype>com.threed.jpct.Matrix</returntype>
        </method>
        <method>
            <name>fillDump</name>
            <comment>Dumps a matrix row-wise into a given float[16]-array and returns it.
 -
 dump - the "dump"</comment>
            <returntype>float[]</returntype>
            <parameter>
                <name>dump</name>
                <type>float[]</type>
            </parameter>
        </method>
        <method>
            <name>transformToGL</name>
            <comment>Transforms a matrix from jPCT's coordinate system into OpenGL's (and vice versa)</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>toString</name>
            <comment>Overrides toString in class java.lang.Object</comment>
            <returntype>java.lang.String</returntype>
        </method>
        <method>
            <name>translate</name>
            <comment>Applies a translation to this matrix.
 -
 trans - the translation</comment>
            <returntype>void</returntype>
            <parameter>
                <name>trans</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>invert2</name>
            <comment>Calculates the inverse of this matrix and fills the result into the 
 given matrix (which will be returned in addition).
 -
 dst - the matrix to fill with the result.</comment>
            <returntype>com.threed.jpct.Matrix</returntype>
            <parameter>
                <name>dst</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
        </method>
        <method>
            <name>getXAxis</name>
            <comment>Returns the x-axis this matrix would represent when viewed as a rotation 
 matrix. This method fills the given SimpleVector in addition to returning
 it.
 -
 toFill - the vector to fill</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>toFill</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <property>
            <name>Translation</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the translation this matrix would represent when viewed as a translation matrix.</comment>
        </property>
        <property>
            <name>YAxis</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the y-axis this matrix would represent when viewed as a rotation matrix.</comment>
        </property>
        <property>
            <name>Dump</name>
            <returntype>float[]</returntype>
            <parameter>
                <name>dump</name>
                <type>float[]</type>
            </parameter>
            <comment>Dumps a matrix row-wise into a float[16]-array.</comment>
        </property>
        <property>
            <name>To</name>
            <parameter>
                <name>source</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
            <comment>Sets this matrix' values to the ones of the source matrix.
 -
 source - the source matrix</comment>
        </property>
        <property>
            <name>ZAxis</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the z-axis this matrix would represent when viewed as a rotation matrix.</comment>
        </property>
        <property>
            <name>XAxis</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the x-axis this matrix would represent when viewed as a rotation matrix.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JLogger</name>
        <shortname>JpctLogger</shortname>
        <objectwrapper>com.threed.jpct.Logger</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Initialize Logger</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>ON_ERROR_EXIT</name>
            <comment>Exit after an error occurs</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>isDebugEnabled</name>
            <comment>Returns true, if debug log level is active.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>ON_ERROR_THROW_EXCEPTION</name>
            <comment>Throw a RuntimeException in case of an error (default)</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>LL_ONLY_ERRORS</name>
            <comment>Log-Level: log errors only</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>log2</name>
            <comment>Logs a message, error or warning. Errors and warnings are logged with a time-stamp.
 -
 msg - the message to log
 type - the type of message</comment>
            <returntype>void</returntype>
            <parameter>
                <name>msg</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>type</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>log</name>
            <comment>Logs a message. A short cut to log(, Logger.MESSAGE);
 -
 msg - the message</comment>
            <returntype>void</returntype>
            <parameter>
                <name>msg</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>LL_VERBOSE</name>
            <comment>Log-Level: log everything but debug (default)</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>MESSAGE</name>
            <comment>The message is just that: a message</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>LL_ERRORS_AND_WARNINGS</name>
            <comment>Log-Level: log errors and warnings</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>ON_ERROR_RESUME_NEXT</name>
            <comment>Try to continue even in case of an error</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>LL_DEBUG</name>
            <comment>Log-Level: log everything including debug</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>DEBUG</name>
            <comment>A debug message</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>LogLevel</name>
            <returntype>int</returntype>
            <parameter>
                <name>level</name>
                <type>int</type>
            </parameter>
            <comment>Returns the log-level. return the log-level</comment>
        </property>
        <property>
            <name>OnError</name>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <comment>Sets error behaviour. The logger can terminate the VM in case of an error, 
 throw an exception or try to continue. Throwing an exception is default.
 -
 mode - the error mode</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JLoader</name>
        <shortname>JpcLoader</shortname>
        <objectwrapper>com.threed.jpct.Loader</objectwrapper>
        <owner>process</owner>
        <method>
            <name>clearCache</name>
            <comment>Empties the file-cache. Useful to free some memory after loading has definitly finished.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>arrayToList</name>
            <comment>Converts array Object3D[] to B4A List.</comment>
            <returntype>anywheresoftware.b4a.objects.collections.List</returntype>
            <parameter>
                <name>Obj3D</name>
                <type>com.threed.jpct.Object3D[]</type>
            </parameter>
        </method>
        <method>
            <name>loadOBJ</name>
            <comment>Loads a file in OBJ-format into an array of objects. OBJ is Wavefront's Advanced 
 Visualizer format supported by many converter tools. A OBJ-file can contain many 
 different objects/groups. Each object will be named like its OBJ-name (the name 
 this object has in the file) plus a suffix "_jPCT" plus the object's internal ID. 
 This loader loads polygonal information only (i.e. no splines and similar things) 
 and supports polygons with up to 4 vertices. Everything higher will be loaded with 
 a warning and most likely not displayed correctly.
 The loader will read the textures' names out of the OBJ-file and will add dummy 
 textures with these names to the texture-manager (If the name is already in use,
 no new dummy texture will be added). So one may load some textures and add them to 
 the manager with the appropiate names before loading the OBJ-file or replace the 
 ones generated by the loader after loading is finished. If the materials used in 
 the file are not using textures, small, single colored textures will be generated 
 that represent the diffuse colors of the materials. This method is for accessing 
 files from an InputStream.
 -
 objStream - the InputStream of the actual OBJ-file
 mtlStream - the InputStream of the material file. May be null.
 scale - a scaling parameter to scale the object right after loading. Should be set to 1 to avoid rescaling</comment>
            <returntype>com.threed.jpct.Object3D[]</returntype>
            <parameter>
                <name>objStream</name>
                <type>java.io.InputStream</type>
            </parameter>
            <parameter>
                <name>mtlStream</name>
                <type>java.io.InputStream</type>
            </parameter>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>loadSerializedObjectArray</name>
            <comment>Loads an object in serialized format. This format can't be created by jPCT-AE 
 but by using the desktop version of jPCT by using the DeSerializer. This is 
 the fastest and least memory intense way to load an object in jPCT-AE.
 -
 is - the inputstream</comment>
            <returntype>com.threed.jpct.Object3D[]</returntype>
            <parameter>
                <name>is</name>
                <type>java.io.InputStream</type>
            </parameter>
        </method>
        <method>
            <name>load3DSMerged</name>
            <comment>Loads a file in 3DS-format and merges all its sub-objects into single object. 
 3DS is a 3D-Studio format supported by many converter tools. A 3DS-file can 
 contain many different objects. Each object will be named like its 3DS-name 
 (the name this object has in 3D-Studio) plus a suffix "_jPCT" plus the object's 
 internal ID. The loader will read the textures' names out of the 3DS-file and
 will add dummy textures with these names to the texture-manager (If the name 
 is already in use, no new dummy texture will be added). So one may load some 
 textures and add them to the manager with the appropiate names before loading 
 the 3DS-file or replace the ones generated by the loader after loading is 
 finished. If the materials used in the file are not using textures, small, 
 single colored textures will be generated that represent the diffuse colors
 of the materials. This method is for accessing files from an InputStream.
 -
 stream - the InputStream
 scale - a scaling parameter to scale the object right after loading. Should 
 be set to 1 to avoid rescaling</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>stream</name>
                <type>java.io.InputStream</type>
            </parameter>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>loadSerializedObject</name>
            <comment>Loads an object in serialized format. This format can't be created by jPCT-AE 
 but by using the desktop version of jPCT by using the DeSerializer. This is 
 the fastest and least memory intense way to load an object in jPCT-AE.
 -
 is - the inputstream</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>is</name>
                <type>java.io.InputStream</type>
            </parameter>
        </method>
        <method>
            <name>readTextureNames3DS</name>
            <comment>Reads the texture names from a 3DS-file.
 -
 stream - the input stream for the file</comment>
            <returntype>java.lang.String[]</returntype>
            <parameter>
                <name>stream</name>
                <type>java.io.InputStream</type>
            </parameter>
        </method>
        <method>
            <name>load3DS</name>
            <comment>Loads a file in 3DS-format into an array of objects. 3DS is a 3D-Studio format 
 supported by many converter tools. A 3DS-file can contain many different objects. 
 Each object will be named like its 3DS-name (the name this object has in 3D-Studio) 
 plus a suffix "_jPCT" plus the object's internal ID. The loader will read the 
 textures' names out of the 3DS-file and will add dummy textures with these names 
 to the texture-manager (If the name is already in use, no new dummy texture will 
 be added). So one may load some textures and add them to the manager with the
 appropiate names before loading the 3DS-file or replace the ones generated by the 
 loader after loading is finished. If the materials used in the file are not using 
 textures, small, single colored textures will be generated that represent the diffuse
 colors of the materials. This method is for accessing files from an InputStream.
 -
 stream - the InputStream
 scale - a scaling parameter to scale the object right after loading. Should be set 
 to 1 to avoid rescaling</comment>
            <returntype>com.threed.jpct.Object3D[]</returntype>
            <parameter>
                <name>stream</name>
                <type>java.io.InputStream</type>
            </parameter>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>loadOBJMerged</name>
            <comment>Loads a file in OBJ-format and merges all its sub-objects into single object. 
 OBJ is Wavefront's Advanced Visualizer format supported by many converter tools. 
 A OBJ-file can contain many different objects/groups. Each object will be named 
 like its OBJ-name (the name this object has in the file) plus a suffix "_jPCT" 
 plus the object's internal ID. This loader loads polygonal information only 
 (i.e. no splines and similar things) and supports polygons with up to 4 vertices. 
 Everything higher will be loaded with a warning and most likely not displayed 
 correctly.
 The loader will read the textures' names out of the OBJ-file and will add dummy 
 textures with these names to the texture-manager (If the name is already in use, 
 no new dummy texture will be added). So one may load some textures and add them 
 to the manager with the appropiate names before loading the OBJ-file or replace 
 the ones generated by the loader after loading is finished. If the materials used
 in the file are not using textures, small, single colored textures will be 
 generated that represent the diffuse colors of the materials. This method is for 
 accessing files from an InputStream.
 -
 objStream - the InputStream of the actual OBJ-file
 mtlStream - the InputStream of the material file. May be null.
 scale - a scaling parameter to scale the object right after loading. Should be set to 1 to avoid rescaling</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>objStream</name>
                <type>java.io.InputStream</type>
            </parameter>
            <parameter>
                <name>mtlStream</name>
                <type>java.io.InputStream</type>
            </parameter>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>loadTextFile</name>
            <comment>Loads a text-file into a String. Used internally by jPCT and maybe useful for 
 other applications. This method is for accessing files from an InputStream.
 -
 stream - the InputStream</comment>
            <returntype>java.lang.String</returntype>
            <parameter>
                <name>stream</name>
                <type>java.io.InputStream</type>
            </parameter>
        </method>
        <method>
            <name>loadMD2</name>
            <comment>Loads an object out of a file in MD2-format (Quake2 model format). The object 
 is loaded including all keyframes so that the returned object already contains
 the animation for this object. The texture indicated in the file is ignored 
 (the texture coordinates are of course not). All meshes of the animation will
 be stored in compressed format. This method is for accessing files from an 
 InputStream.
 -
 stream - the InputStream
 newScale - a scaling parameter, 1 means no changes to the mesh</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>ba</name>
                <type>anywheresoftware.b4a.BA</type>
            </parameter>
            <parameter>
                <name>stream</name>
                <type>java.io.InputStream</type>
            </parameter>
            <parameter>
                <name>newScale</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>loadASC</name>
            <comment>Loads a file in ASC-format into an object. ASC is an ASCII-based 3D-Studio 
 format supported by many converter tools. This method is for accessing files
 from an InputStream.
 -
 stream - the InputStream
 scale - a scaling parameter to scale the object right after loading. Should 
 be set to 1 to avoid rescaling
 swap - if set to true, y and z coordinates of the object will be swaped. 
 This could be helpful for correct backface culling on some Object3Ds.</comment>
            <returntype>com.threed.jpct.Object3D</returntype>
            <parameter>
                <name>stream</name>
                <type>java.io.InputStream</type>
            </parameter>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>swap</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>VertexOptimization</name>
            <parameter>
                <name>enabled</name>
                <type>boolean</type>
            </parameter>
            <comment>Enables(default)/Disables vertex optimizations for the Loader. Using this, 
 vertices can be combined to one if they cover exactly the same point in space. 
 This reduces vertex count. If you disable this, be sure to have a reason... 
 This setting affects ASC, 3DS and OBJ files only. If used for loading 3DS or
 OBJ files, the vertex sharing information from the files will be used instead 
 (Could be helpful to use these files as keyframes).
 -
 enabled - optimize vertex usage</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JLight</name>
        <shortname>JpcLight</shortname>
        <objectwrapper>com.threed.jpct.Light</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Creates a new light in the world. The light will be placed at (0,0,0)
 and with an intensity of (255,255,255).
 -
 world - the instance of world</comment>
            <returntype>void</returntype>
            <parameter>
                <name>world</name>
                <type>com.threed.jpct.World</type>
            </parameter>
        </method>
        <method>
            <name>LIGHT_INVISIBLE</name>
            <comment>he light is not visible</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>rotate</name>
            <comment>Rotates the light around a rotation pivot. Unlike the similar methods in World, this 
 doesn't cause the light to execute this rotation every frame (which was stupid idea 
 anyway...:-)). This is done, when you are calling the method. Not more, not less.
 -
 degrees - a SimpleVector that contains the rotation angles in its x,y,z-components
 pivot - SimpleVector the rotation pivot</comment>
            <returntype>void</returntype>
            <parameter>
                <name>degrees</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>pivot</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>enable</name>
            <comment>Enables a light. Each new light is enabled by default.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>isEnabled</name>
            <comment>Is the light enabled?</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>LIGHT_VISIBLE</name>
            <comment>The light is visible</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>getPosition2</name>
            <comment>Returns the position of this light in world space.
 -
 store - an optional SimpleVector (may be null), in which the position will be stored. 
 If given, this is the vector that will be returned too.</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>store</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>setIntensity2</name>
            <comment>Sets the light's intensity.
 -
 red - the red intensity
 green - the green intensity
 blue - the blue intensity</comment>
            <returntype>void</returntype>
            <parameter>
                <name>red</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>green</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>blue</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>disable</name>
            <comment>Disables a light. The light is still part of the world, just not visible.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>DistanceOverride</name>
            <returntype>float</returntype>
            <parameter>
                <name>distance</name>
                <type>float</type>
            </parameter>
            <comment>Returns the overriden distance. If none is set, -1 will be returned.</comment>
        </property>
        <property>
            <name>DiscardDistance</name>
            <returntype>float</returntype>
            <parameter>
                <name>dist</name>
                <type>float</type>
            </parameter>
            <comment>Gets the discard distance of this light, if it has be set before. If it hasn't, 
 the result of this call in undefined (but lower than -1).</comment>
        </property>
        <property>
            <name>Intensity</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>inty</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <comment>gets a SimpleVector that contains the intensities of r,g,b in its x,y,z-components.</comment>
        </property>
        <property>
            <name>Position</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>pos</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <comment>Returns the position of this light in world space.</comment>
        </property>
        <property>
            <name>Attenuation</name>
            <returntype>float</returntype>
            <parameter>
                <name>att</name>
                <type>float</type>
            </parameter>
            <comment>Returns the light's attenuation.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JLensFlare</name>
        <shortname>JpctLensFlare</shortname>
        <objectwrapper>com.threed.jpct.util.LensFlare</objectwrapper>
        <owner>process</owner>
        <method>
            <name>update</name>
            <comment>Updates the lens flare. Skipping this method and calling render only will cause the 
 lens flare to remain static. This method should be called if either the camera or,
 if hiding is enabled, the hiding objects are moving.
 -
 buffer - the frame buffer
 world - the world</comment>
            <returntype>void</returntype>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>world</name>
                <type>com.threed.jpct.World</type>
            </parameter>
        </method>
        <method>
            <name>Initialize</name>
            <comment>Create a new lens flare for a light source.
 -
 lightPos - the position of the light source
 burst - the name of the burst texture as added to the TextureManager
 halo1 - the name of the first halo texture as added to the TextureManager
 halo2 - the name of the second halo as added to the TextureManager
 halo3 - the name of the third halo texture added to the TextureManager</comment>
            <returntype>void</returntype>
            <parameter>
                <name>lightPos</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>burst</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>halo1</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>halo2</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>halo3</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>render</name>
            <comment>Renders the effect.
 -
 buffer - the frame buffer</comment>
            <returntype>void</returntype>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
        </method>
        <property>
            <name>Hiding</name>
            <parameter>
                <name>hides</name>
                <type>boolean</type>
            </parameter>
            <comment>If true (default), all geometry that is a potential collider hides the effect 
 if it's located in a direct line between the camera and the light source.
 -
 hides - should geometry hide it or not?</comment>
        </property>
        <property>
            <name>GlobalScale</name>
            <parameter>
                <name>scale</name>
                <type>float</type>
            </parameter>
            <comment>Sets the global scale of the effect.
 -
 scale - the scale</comment>
        </property>
        <property>
            <name>Transparency</name>
            <parameter>
                <name>trans</name>
                <type>int</type>
            </parameter>
            <comment>Sets the transparency of the effect.
 -
 trans - the transparency. 0 is lowest</comment>
        </property>
        <property>
            <name>LightPosition</name>
            <parameter>
                <name>lightPos</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <comment>Sets a new light position.
 -
 lightPos - the new position</comment>
        </property>
        <property>
            <name>MaximumDistance</name>
            <parameter>
                <name>distance</name>
                <type>float</type>
            </parameter>
            <comment>If hiding is enabled, this value specifies how far away from the camera a polygon
 can maximally be to be considered as a blocker. Anything farer away can't hide the
 effect. Lowering this value can improve performance but may lead to flares where 
 non should be. -1 is default, which means no limits.
 -
 distance - the distance</comment>
        </property>
        <property>
            <name>Direction</name>
            <parameter>
                <name>lightToCam</name>
                <type>boolean</type>
            </parameter>
            <comment>If hiding is enabled, the visibility calculations can be done camera-&gt;light (default) 
 or light-&gt;camera. Depending on the scene, one or the other will be faster.
 -
 lightToCam - do it light-&gt;camera or vice versa</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JIntList</name>
        <shortname>JpctIntList</shortname>
        <objectwrapper>com.threed.jpct.IntList</objectwrapper>
        <owner>process</owner>
        <method>
            <name>clear</name>
            <comment>Clears the list.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>Initialize</name>
            <comment>Initialize IntList</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>compact</name>
            <comment>Truncates unused parts from the internal storage list, so that the resulting list doesn't 
 require more memory than it has to. However, calling this method will cause a little memory 
 usage peak.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>get</name>
            <comment>Adds an int to the list.
 -
 i - the int</comment>
            <returntype>int</returntype>
            <parameter>
                <name>pos</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>add</name>
            <comment>Adds an int to the list.
 -
 i - the int</comment>
            <returntype>void</returntype>
            <parameter>
                <name>i</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>size</name>
            <comment>Returns the size of the list.</comment>
            <returntype>int</returntype>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JInteract2D</name>
        <shortname>JpctInteract2D</shortname>
        <objectwrapper>com.threed.jpct.Interact2D</objectwrapper>
        <owner>process</owner>
        <method>
            <name>reproject2D3DWS</name>
            <comment>Reprojects a 2D vector (a screen/framebuffer coordinate in most cases)
 back into 3D (world space). The Z-value is assumed to be 1.
 -
 camera - the camera used to render the scene
 buffer - the framebuffer containing the rendered image
 x - the x position in 2D
 y - the y position in 2D</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>camera</name>
                <type>com.threed.jpct.Camera</type>
            </parameter>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>x</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>projectCenter3D2D2</name>
            <comment>Gets the center of the object in screen-coordinates (2D) by transforming and 
 projecting it from 3D objectspace into 2D screenspace. Useful to "attach" 
 bitmaps to objects for example. This method uses the current camera of the 
 World the object has been assigned to.
 -
 camera - the camera that represents the worldspace-&gt;cameraspace transformation. The frontbuffer matrix of the camera will be used. If the camera is null, the one from the object's World will be used instead.
 buffer - the framebuffer the object will be (or has been) rendered into
 obj - the object itself</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>camera</name>
                <type>com.threed.jpct.Camera</type>
            </parameter>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>reproject2D3DWS2</name>
            <comment>Reprojects a 2D vector (a screen/framebuffer coordinate in most cases) 
 back into 3D (world space). The Z-value is assumed to be 1.
 -
 camera - the camera used to render the scene
 buffer - the framebuffer containing the rendered image
 x - the x position in 2D
 y - the y position in 2D
 toFill - a SimpleVector that will be filled with the result</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>camera</name>
                <type>com.threed.jpct.Camera</type>
            </parameter>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>x</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>toFill</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>reproject2D3D</name>
            <comment>Reprojects a 2D vector (a screen/framebuffer coordinate in most cases) back 
 into 3D. The Z-value is assumed to be 1.
 -
 camera - the camera used to render the scene
 buffer - the framebuffer containing the rendered image
 x - the x position in 2D
 y - the y position in 2D</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>camera</name>
                <type>com.threed.jpct.Camera</type>
            </parameter>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>x</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>reproject2D3D2</name>
            <comment>Reprojects a 2D vector (a screen/framebuffer coordinate in most cases) back 
 into 3D. The Z-value is assumed to be 1.
 -
 camera - the camera used to render the scene
 buffer - the framebuffer containing the rendered image
 x - the x position in 2D
 y - the y position in 2D
 toFill - a SimpleVector that will be filled with the result</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>camera</name>
                <type>com.threed.jpct.Camera</type>
            </parameter>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>x</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>toFill</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>reproject2D3D3</name>
            <comment>Reprojects a 2D vector (a screen/framebuffer coordinate in most cases) back 
 into 3D with a given z (in 3D).
 -
 camera - the camera used to render the scene
 buffer - the framebuffer containing the rendered image
 x - the x position in 2D
 y - the y position in 2D
 z - the z position of the "picking plane" (in 3D)</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>camera</name>
                <type>com.threed.jpct.Camera</type>
            </parameter>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>x</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>z</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>reproject2D3D4</name>
            <comment>Reprojects a 2D vector (a screen/framebuffer coordinate in most cases) back 
 into 3D with a given z (in 3D).
 -
 camera - the camera used to render the scene
 buffer - the framebuffer containing the rendered image
 x - the x position in 2D
 y - the y position in 2D
 z - the z position of the "picking plane" (in 3D)
 toFill - a SimpleVector that will be filled with the result</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>camera</name>
                <type>com.threed.jpct.Camera</type>
            </parameter>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>x</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>z</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>toFill</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>project3D2D</name>
            <comment>Projects a vertex from world space into screen space.
 camera - the Camera used for the projection
 buffer - the Framebuffer
 vertex - the vertex in world space</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>camera</name>
                <type>com.threed.jpct.Camera</type>
            </parameter>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>vertex</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>project3D2D2</name>
            <comment>Projects a vertex from world space into screen space. This variant takes a 
 SimpleVector to fill instead of creating a new one for each call.
 -
 camera - the Camera used for the projection
 buffer - the Framebuffer
 vertex - the vertex in world space
 toFill - the SimpleVector that will be filled with the result</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>camera</name>
                <type>com.threed.jpct.Camera</type>
            </parameter>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>vertex</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>toFill</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>projectCenter3D2D</name>
            <comment>Gets the center of the object in screen-coordinates (2D) by transforming and 
 projecting it from 3D objectspace into 2D screenspace. Useful to "attach" 
 bitmaps to objects for example. This method uses the current camera of the 
 World the object has been assigned to.
 -
 buffer - the framebuffer the object will be (or has been) rendered into
 obj - the object itself</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
            <parameter>
                <name>obj</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JGLSurfaceView</name>
        <shortname>JpctSurface</shortname>
        <objectwrapper>android.opengl.GLSurfaceView</objectwrapper>
        <owner>activity</owner>
        <event>SurfaceTouch(motionEvent As JpctMotionEvent, scaleEvent As JpctScaleEvent, gestureEvent As JpctGestureEvent) As Boolean</event>
        <event>SurfaceCreated</event>
        <event>SurfaceChanged(Width as int, Height as int)</event>
        <event>SurfaceDraw</event>
        <method>
            <name>BufferWidth</name>
            <comment>FrameBuffer's Width</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>RequestFocus</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>BringToFront</name>
            <comment></comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>RGBX_8888</name>
            <comment>PixelFormat_RGBX_8888</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>RemoveView</name>
            <comment></comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>SetBackgroundImage</name>
            <comment></comment>
            <returntype>void</returntype>
            <parameter>
                <name>arg0</name>
                <type>android.graphics.Bitmap</type>
            </parameter>
        </method>
        <method>
            <name>OPAQUE</name>
            <comment>PixelFormat_OPAQUE</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>DEBUG_CHECK_GL_ERROR</name>
            <comment>Check glError() after every GL call and throw an exception if 
 glError indicates that an error has occurred. This can be used 
 to help track down which OpenGL ES call is causing an error.
 Constant Value: 1</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>Invalidate3</name>
            <comment></comment>
            <returntype>void</returntype>
            <parameter>
                <name>arg0</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>arg1</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>arg2</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>arg3</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>onResume</name>
            <comment>Inform the view that the activity is resumed. The owner of this 
 view must call this method when the activity is resumed. Calling 
 this method will recreate the OpenGL display and resume the 
 rendering thread. Must not be called before a renderer has been 
 set.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>Invalidate2</name>
            <comment></comment>
            <returntype>void</returntype>
            <parameter>
                <name>arg0</name>
                <type>android.graphics.Rect</type>
            </parameter>
        </method>
        <method>
            <name>RGB_565</name>
            <comment>PixelFormat_RGB_565</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Initialize the GLSurfaceView for some devices (i.e Samsung I7500)
 EventName - The name of event that will get the updates/notifications
 glVersion - sets the required OpenGL version (Default 1)
 renderMode - sets the surface's render mode (Default CONTINUOUSLY=1)
 debug - turn-on error-checking/logging
 
 I.e:&lt;code&gt;
 Dim jpctView As JpctSurface
 jpctView.Initialize2("jpctEvent", 1, jpctView.RENDER_CONTINUOUSLY, True)&lt;/code&gt;</comment>
            <returntype>void</returntype>
            <parameter>
                <name>ba</name>
                <type>anywheresoftware.b4a.BA</type>
            </parameter>
            <parameter>
                <name>EventName</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>glVersion</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>renderMode</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>debug</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>Initialize3</name>
            <comment>Initialize a customized GLSurfaceView
 EventName - The name of event that will get the updates/notifications
 glVersion - sets the required OpenGL version (Default 1)
 redSize - the red size of the FrameBuffer
 greenSize - the green size of the FrameBuffer
 blueSize - the blue size of the FrameBuffer
 alphaSize - the alpha size of the FrameBuffer
 depthSize - the depth size of the FrameBuffer
 stencilSize - the stencil size of the FrameBuffer
 antiAliasing - - Enable/Disable OpenGL 2.0 Anti-Aliasing feature
 renderMode - sets the surface's render mode (Default CONTINUOUSLY=1)
 debug - error-checking/logging
 transparentSurface - need transparent surfaceView?
 
 I.e:&lt;code&gt;
 Dim jpctView As JpctSurface
 jpctView.Initialize3("jpctEvent", 1, 8, 8, 8, 8, 16, 4, True, jpctView.RENDER_CONTINUOUSLY, False, jpctView.RGBA_8888)&lt;/code&gt;</comment>
            <returntype>void</returntype>
            <parameter>
                <name>ba</name>
                <type>anywheresoftware.b4a.BA</type>
            </parameter>
            <parameter>
                <name>EventName</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>glVersion</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>redSize</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>greenSize</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>blueSize</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>alphaSize</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>depthSize</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>stencilSize</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>antiAliasing</name>
                <type>boolean</type>
            </parameter>
            <parameter>
                <name>renderMode</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>debug</name>
                <type>boolean</type>
            </parameter>
            <parameter>
                <name>pixelFormat</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>RENDER_WHEN_DIRTY</name>
            <comment>The renderer only renders when the surface is created, or 
 when requestRender() is called.
 Constant Value: 0</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>Initialize1</name>
            <comment>Initialize the GLSurfaceView
 EventName - The name of event that will get the updates/notifications
 glVersion - sets the required OpenGL version
 antiAliasing - Enable/Disable OpenGL 2.0 Anti-Aliasing feature
 renderMode - sets the surface's render mode
 debug - error-checking/logging
 transparentSurface - need transparent surfaceView?	
 
 I.e:&lt;code&gt;
 Dim jpctView As JpctSurface
 jpctView.Initialize1("jpctEvent", 1, True, jpctView.RENDER_CONTINUOUSLY, False, jpctView.TRANSLUCENT)&lt;/code&gt;</comment>
            <returntype>void</returntype>
            <parameter>
                <name>ba</name>
                <type>anywheresoftware.b4a.BA</type>
            </parameter>
            <parameter>
                <name>EventName</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>glVersion</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>antiAliasing</name>
                <type>boolean</type>
            </parameter>
            <parameter>
                <name>renderMode</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>debug</name>
                <type>boolean</type>
            </parameter>
            <parameter>
                <name>pixelFormat</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>Initialize</name>
            <comment>Initialize the GLSurfaceView
 EventName - The name of event that will get the updates/notifications
 glVersion - sets the required OpenGL version
 renderMode - sets the surface's render mode
 
 I.e:&lt;code&gt;
 Dim jpctView As JpctSurface
 jpctView.Initialize("jpctEvent", 1, jpctView.RENDER_WHEN_DIRTY)&lt;/code&gt;</comment>
            <returntype>void</returntype>
            <parameter>
                <name>ba</name>
                <type>anywheresoftware.b4a.BA</type>
            </parameter>
            <parameter>
                <name>EventName</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>glVersion</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>renderMode</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>destroyDrawingCache</name>
            <comment>Destroy the drawing cache</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>TRANSLUCENT</name>
            <comment>PixelFormat_TRANSLUCENT</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>RGBA_4444</name>
            <comment>PixelFormat_RGBA_4444</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>RENDER_CONTINUOUSLY</name>
            <comment>The renderer is called continuously to re-render the scene.
 Constant Value: 1</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>DEBUG_LOG_GL_CALLS</name>
            <comment>Log GL calls to the system log at "verbose" level with tag 
 "GLSurfaceView".
 Constant Value: 2</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>RGB_332</name>
            <comment>PixelFormat_RGB_332</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>glContext</name>
            <comment>OpenGL Context</comment>
            <returntype>javax.microedition.khronos.opengles.GL10</returntype>
        </method>
        <method>
            <name>SendArrayDataTo</name>
            <comment>Send Data (Array of Objects) To UI thread
 SubName, Name of the Sub to send to, ie. "MySub"
 ArrayData, The Array of Data Objects you need to send</comment>
            <returntype>void</returntype>
            <parameter>
                <name>SubName</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>ArrayData</name>
                <type>java.lang.Object[]</type>
            </parameter>
        </method>
        <method>
            <name>SetLayout</name>
            <comment></comment>
            <returntype>void</returntype>
            <parameter>
                <name>arg0</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>arg1</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>arg2</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>arg3</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>Invalidate</name>
            <comment></comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>TRANSPARENT</name>
            <comment>PixelFormat_TRANSPARENT</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>BufferHeight</name>
            <comment>FrameBuffer's Height</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>onPause</name>
            <comment>Inform the view that the activity is paused. The owner of this 
 view must call this method when the activity is paused. Calling 
 this method will pause the rendering thread. Must not be called 
 before a renderer has been set.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>RequestRender</name>
            <comment>Request that the renderer render a frame. This method is typically 
 used when the render mode has been set to RENDER_WHEN_DIRTY, so 
 that frames are only rendered on demand. May be called from any 
 thread. Must not be called before a renderer has been set.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>RGBA_8888</name>
            <comment>PixelFormat_RGBA_8888</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>RGBA_5551</name>
            <comment>PixelFormat_RGBA_5551</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>RGB_888</name>
            <comment>PixelFormat_RGB_888</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>SendToBack</name>
            <comment></comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>SendDataTo</name>
            <comment>Send Data (Single Object) To UI thread
 SubName: Name of the Sub to send to, ie. "MySub"
 Data: The Data Object you need to send</comment>
            <returntype>void</returntype>
            <parameter>
                <name>SubName</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>Data</name>
                <type>java.lang.Object</type>
            </parameter>
        </method>
        <property>
            <name>Top</name>
            <returntype>int</returntype>
            <parameter>
                <name>arg0</name>
                <type>int</type>
            </parameter>
            <comment></comment>
        </property>
        <property>
            <name>Enabled</name>
            <returntype>boolean</returntype>
            <parameter>
                <name>arg0</name>
                <type>boolean</type>
            </parameter>
            <comment></comment>
        </property>
        <property>
            <name>DebugFlags</name>
            <returntype>int</returntype>
            <parameter>
                <name>debugFlags</name>
                <type>int</type>
            </parameter>
            <comment>Get the current value of the debug flags.</comment>
        </property>
        <property>
            <name>Visible</name>
            <returntype>boolean</returntype>
            <parameter>
                <name>arg0</name>
                <type>boolean</type>
            </parameter>
            <comment></comment>
        </property>
        <property>
            <name>Background</name>
            <returntype>android.graphics.drawable.Drawable</returntype>
            <parameter>
                <name>arg0</name>
                <type>android.graphics.drawable.Drawable</type>
            </parameter>
            <comment></comment>
        </property>
        <property>
            <name>Height</name>
            <returntype>int</returntype>
            <parameter>
                <name>arg0</name>
                <type>int</type>
            </parameter>
            <comment></comment>
        </property>
        <property>
            <name>Left</name>
            <returntype>int</returntype>
            <parameter>
                <name>arg0</name>
                <type>int</type>
            </parameter>
            <comment></comment>
        </property>
        <property>
            <name>Color</name>
            <parameter>
                <name>arg0</name>
                <type>int</type>
            </parameter>
            <comment></comment>
        </property>
        <property>
            <name>GLWrapper</name>
            <parameter>
                <name>glWrapper</name>
                <type>android.opengl.GLSurfaceView.GLWrapper</type>
            </parameter>
            <comment>Set the glWrapper. If the glWrapper is not null, its wrap(GL) method 
 is called whenever a surface is created. A GLWrapper can be used to 
 wrap the GL object that's passed to the renderer. Wrapping a GL object
 enables examining and modifying the behavior of the GL calls made by the 
 renderer.</comment>
        </property>
        <property>
            <name>Tag</name>
            <returntype>java.lang.Object</returntype>
            <parameter>
                <name>arg0</name>
                <type>java.lang.Object</type>
            </parameter>
            <comment></comment>
        </property>
        <property>
            <name>Width</name>
            <returntype>int</returntype>
            <parameter>
                <name>arg0</name>
                <type>int</type>
            </parameter>
            <comment></comment>
        </property>
        <property>
            <name>RenderMode</name>
            <returntype>int</returntype>
            <comment>Get the current rendering mode. May be called from any thread. 
 Must not be called before a renderer has been set.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JGLSLShader</name>
        <shortname>JpctGLSLShader</shortname>
        <objectwrapper>com.threed.jpct.GLSLShader</objectwrapper>
        <owner>process</owner>
        <method>
            <name>addReplacement</name>
            <comment>With this, you can override the default shaders by making jPCT-AE use your
 own shader code instead. Valid names for key are:
 defaultFragmentShader.src
 defaultFragmentShaderDepth.src
 defaultFragmentShaderFog.src
 defaultFragmentShaderFogLight0.src
 defaultFragmentShaderTex0.src
 defaultFragmentShaderTex0Amb.src
 defaultFragmentShaderTex0Light0.src
 defaultFragmentShaderTex1.src
 defaultVertextShader.src
 defaultVertexShaderDepth.src
 defaultVertexShaderFog.src
 defaultVertexShaderFogLight0.src
 defaultVertexShaderTex0.src
 defaultVertexShaderTex0Amb.src
 defaultVertexShaderTex0Light0.src
 defaultVertexShaderTex1.src</comment>
            <returntype>void</returntype>
            <parameter>
                <name>key</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>shaderSrc</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>setUniform</name>
            <comment>Sets a new integer uniform. This value will be set each time the shader is executed. 
 You may change it at runtime.
 -
 name - the name of the uniform
 val - the value</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>val</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>setStaticUniform5</name>
            <comment>Sets a new SimpleVector uniform. Static means, that this value will be set only once. 
 If you want to change the value at runtime, use setUniform(...) instead.
 -
 name - the name of the uniform
 val - the value.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>val</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>setStaticUniform4</name>
            <comment>Sets a new array of SimpleVector uniform. Static means, that this value will be set 
 only once. If you want to change the value at runtime, use setUniform(...) instead.
 -
 name - the name of the uniform
 val - the value.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>vals</name>
                <type>com.threed.jpct.SimpleVector[]</type>
            </parameter>
        </method>
        <method>
            <name>setStaticUniform</name>
            <comment>Sets a new integer uniform. Static means, that this value will be set only once.
 If you want to change the value at runtime, use setUniform(...) instead.
 -
 name - the name of the uniform
 val - the value</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>val</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>setStaticUniform6</name>
            <comment>Sets a new Matrix uniform. Static means, that this value will be set only once. If you 
 want to change the value at runtime, use setUniform(...) instead.
 -
 name - the name of the uniform
 m - the matrix. It won't be transposed.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>m</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
        </method>
        <method>
            <name>setStaticUniform2</name>
            <comment>Sets a new float uniform. Static means, that this value will be set only once. 
 If you want to change the value at runtime, use setUniform(...) instead.
 -
 name - the name of the uniform
 val - the value</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>val</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>setStaticUniform3</name>
            <comment>Sets a new float|vecX uniform. Static means, that this value will be set only once. 
 If you want to change the value at runtime, use setUniform(...) instead.
 -
 name - the name of the uniform
 val - the value. Supports array-lengths from 1 to 4.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>val</name>
                <type>float[]</type>
            </parameter>
        </method>
        <method>
            <name>finalize</name>
            <comment>finalize in class java.lang.Object</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>Initialize</name>
            <comment>Creates a new instance. This instance can then be passed to any 
 Object3D that should use this shader. You may pass one instance 
 to multiple Object3D's. Please note that both parameters are not 
 the paths to the shader sources but the shader sources themselves. 
 The shaders won't be compiled before their first usage, so you may 
 pass bogus shader code here, but you'll not notice it, until you are 
 trying to render the object using that shader.
 -
 vertexShaderSrc - the source of the vertex shader
 fragmentShaderSrc - the source of the fragment shader</comment>
            <returntype>void</returntype>
            <parameter>
                <name>vertexShaderSource</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>fragmentShaderSource</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>dispose</name>
            <comment>Disposes the shader. Usually, there's no need to call this.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>getHandle</name>
            <comment>?</comment>
            <returntype>int</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>setFloatArrayUniform</name>
            <comment>Sets a new float[] uniform. This value will be set each time the shader is executed. 
 You may change it at runtime.
 -
 name - the name of the uniform
 val - the value. Supports array-lengths from 1 to 4.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>val</name>
                <type>float[]</type>
            </parameter>
        </method>
        <method>
            <name>setUniform6</name>
            <comment>Sets a new Matrix uniform. This value will be set each time the shader is executed. 
 You may change it at runtime.
 -
 name - the name of the uniform
 m - the matrix. It won't be transposed.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>m</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
        </method>
        <method>
            <name>setUniform3</name>
            <comment>Sets a new SimpleVector uniform. This value will be set each time the shader is executed. 
 You may change it at runtime.
 -
 name - the name of the uniform
 val - the value</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>val</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>setStaticFloatArrayUniform</name>
            <comment>Sets a new float[] uniform. Static means, that this value will be set only 
 once. If you want to change the value at runtime, use setFloatArrayUniform(...)
 instead.
 -
 name - the name of the uniform
 val - the value.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>val</name>
                <type>float[]</type>
            </parameter>
        </method>
        <method>
            <name>setUniform2</name>
            <comment>Sets a new float uniform. This value will be set each time the shader is executed. 
 You may change it at runtime.
 -
 name - the name of the uniform
 val - the value</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>val</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>setUniform5</name>
            <comment>Sets a new float|vecX uniform. This value will be set each time the shader is executed. 
 You may change it at runtime.
 -
 name - the name of the uniform
 val - the value. Supports array-lengths from 1 to 4.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>val</name>
                <type>float[]</type>
            </parameter>
        </method>
        <method>
            <name>setUniform4</name>
            <comment>Sets a new array of SimpleVectors uniform. This value will be set each time the shader is 
 executed. You may change it at runtime.
 -
 name - the name of the uniform
 val - the value</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>val</name>
                <type>com.threed.jpct.SimpleVector[]</type>
            </parameter>
        </method>
        <property>
            <name>ShaderLocator</name>
            <parameter>
                <name>locator</name>
                <type>com.threed.jpct.ShaderLocator</type>
            </parameter>
            <comment>Sets a new shader locator. If this is needed, it has to be done before 
 instantiating the frame buffer. Please refer to the documention of the 
 ShaderLocator for more information.
 -
 locator - the new locator</comment>
        </property>
        <property>
            <name>Program</name>
            <returntype>int</returntype>
            <comment>Returns the id of the shader program. Can be useful if you want to fiddle 
 around with the shader behind jPCT-AE's back.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JGenericVertexController</name>
        <shortname>JpctVertexController</shortname>
        <objectwrapper>jpct.ae.wrapper.VertexController</objectwrapper>
        <owner>process</owner>
        <event>VertexController(vcEvent as int)</event>
        <method>
            <name>Initialize</name>
            <comment>Initialize the Vertex Controller
 eventName - the name of the Vertex Controller's event</comment>
            <returntype>void</returntype>
            <parameter>
                <name>ba</name>
                <type>anywheresoftware.b4a.BA</type>
            </parameter>
            <parameter>
                <name>eventName</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>refreshMeshData</name>
            <comment>Refreshes the controller's data with the data taken directly from the Mesh. This can be 
 useful to reflect changes to the controller that have been applied to the mesh outside 
 of the controller.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>ALTER_SOURCE_MESH</name>
            <comment>The VertexController will modify the source data when applied, 
 i.e. everything the controller does to the mesh is cumulative 
 over time.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>EVENT_CLEANUP</name>
            <comment>the type - CLEANUP - of the callback event raised by the controller</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>EVENT_SETUP</name>
            <comment>the type - SETUP - of the callback event raised by the controller</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>EVENT_APPLY</name>
            <comment>the type - APPLY - of the callback event raised by the controller</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>getPolygonIDs</name>
            <comment>Returns the polygon IDs of the polygons that are using the vertex "number".
 This can be used to determine which vertices belong to a polygon, which could be useful 
 in some VertexControllers. This should be done at setup time, not at runtime.
 vertex - the number of the vertex
 max - the maximum of IDs to return</comment>
            <returntype>int[]</returntype>
            <parameter>
                <name>vertex</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>max</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>PRESERVE_SOURCE_MESH</name>
            <comment>The VertexController will start with a "fresh" source mesh 
 everytime it's being applied.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>MeshSize</name>
            <returntype>int</returntype>
            <comment>Returns the size of the mesh. This is the length all SimpleVector-array returned by the 
 methods above will have.</comment>
        </property>
        <property>
            <name>DestinationNormals</name>
            <returntype>com.threed.jpct.SimpleVector[]</returntype>
            <comment>Returns the destination mesh's normals. The new normals will be stored in these 
 SimpleVectors. Calculating the vertex normal of a modified vertex is not always cheap. 
 In some cases, one may get away with not modifying the normals at all. This will cause 
 slightly wrong lighting, but eases the calculations. Write into the SimpleVectors of 
 this array, don't read from them.</comment>
        </property>
        <property>
            <name>SourceNormals</name>
            <returntype>com.threed.jpct.SimpleVector[]</returntype>
            <comment>Returns the source mesh's normals, i.e. the normals that need modification.
 Every SimpleVector in this array represents a normal in the mesh. The normal at the 
 specific index is the normal of the corresponding vertex in the SourceMesh-array. 
 Read the data from this array, but don't modify it.</comment>
        </property>
        <property>
            <name>SourceMesh</name>
            <returntype>com.threed.jpct.SimpleVector[]</returntype>
            <comment>Returns the source mesh's vertex data, i.e. the vertex-data that needs modification.
 Every SimpleVector in this array represents a vertex in the mesh. However, there's no
 information which vertex exactly (because they don't have ids or something). Read the
 data from this array, but don't modify it.</comment>
        </property>
        <property>
            <name>DestinationMesh</name>
            <returntype>com.threed.jpct.SimpleVector[]</returntype>
            <comment>Returns the destination mesh's vertex data. The new vertices will be stored in these 
 SimpleVectors. There's no need to replace the SimpleVectors in this array with new ones. 
 Just set their x,y and z components to the new values. Write into the SimpleVectors of
 this array, don't read from them.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JFrameBuffer</name>
        <shortname>JpctFrameBuffer</shortname>
        <objectwrapper>com.threed.jpct.FrameBuffer</objectwrapper>
        <owner>process</owner>
        <method>
            <name>removeRenderTarget</name>
            <comment>Removes the render target from the framebuffer. After this, all rendering is done into the 
 framebuffer again. If no render target has been set, this method does nothing.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>clearZBufferOnly</name>
            <comment>Clears only the ZBuffer, not the color buffer. Can be useful for special effects like 
 rendering two worlds into one frame buffer. Using this method may cause strange renderings 
 on some devices, because they seem to rely on a cleared framebuffer each frame for an 
 unknown reason.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>addPostProcessor</name>
            <comment>Adds an IPostProcessor to run a post processing on the framebuffer. This isn't done
 automatically but has to be triggered by the application by calling runPostProcessors() 
 on this framebuffer. Enabling or disabling renderers on this framebuffer causes all 
 post processors to be disposed and then removed from this framebuffer.
 -
 proc - the post processor</comment>
            <returntype>void</returntype>
            <parameter>
                <name>proc</name>
                <type>com.threed.jpct.IPostProcessor</type>
            </parameter>
        </method>
        <method>
            <name>runPostProcessors</name>
            <comment>Runs all post processors that have been added to this framebuffer. A post processor is 
 an implementation of the IPostProcessor interface. The processing is done on the 
 framebuffer's back buffer in its current state, i.e. if you run it before blitting, 
 the blitting won't be affected. If you run it afterwards, it will.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>clearColorBufferOnly</name>
            <comment>Clears only the color bufferr, not the depth buffer.
 col - the fill color</comment>
            <returntype>void</returntype>
            <parameter>
                <name>col</name>
                <type>com.threed.jpct.RGBColor</type>
            </parameter>
        </method>
        <method>
            <name>setRenderTarget4</name>
            <comment>Sets the render target of the framebuffer to a texture. From here on, all rendering is 
 done into that texture instead of the actual framebuffer. The texture has to be smaller 
 or equal to the framebuffer. This is a special purpose version of this method that allows
 to define a border that isn't affected by the rendering. While possible, it's not recommended
 to blit into a render target. If possible, use OpenGL ES 2.0 mode when using this, because 
 it's much more compatible.
 -
 tex - the texture to render into
 left - the width of the left border
 top - the width of the upper border
 right - the width of the right border
 bottom - the width of the lower border
 clearAll - if true, the border won't affect the clearing of texture. If set to false, it will.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>tex</name>
                <type>com.threed.jpct.Texture</type>
            </parameter>
            <parameter>
                <name>left</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>top</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>right</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>bottom</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>clearAll</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>blit</name>
            <comment>Copies a part of a bitmap (taken from a Texture in this case) into the framebuffer. If you want 
 your blitted content to lay on top of the rendered image, it has to be applied after calling 
 update() on the buffer. This method is useful to copy 2D-GUI elements into the rendered image 
 (or for similar tasks). Blitting requires that the current world has been rendered at least once 
 into the framebuffer where the blitting should be applied to (for doing some intialization work). 
 Usually, that shouldn't be a problem unless you are abusing jPCT as a "blitting engine" only. Be 
 sure that the texture's height is 2^x. Everything else might produce unpredictable results. This 
 method should be prefered over the int[]-array-blit whenever possible.
 -
 src - the texture that contains the source bitmap
 srcX - the starting x-position in the source bitmap
 srcY - the starting y-position in the source bitmap
 destX - the starting x-position in the destination bitmap
 destY - the starting y-position in the destination bitmap
 width - the width of the region to copy
 height - the height of the region to copy
 transparent - black (or at least almost black) pixels won't be copied if this 
 is set to TRANSPARENT_BLITTING. Any color-value which leads to a result of zero when 
 "anded" with #f0f0f0 will be taken as black unless your texture specifies its own 
 alpha channel.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>src</name>
                <type>com.threed.jpct.Texture</type>
            </parameter>
            <parameter>
                <name>srcX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>srcY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>destX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>destY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>width</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>height</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>transparent</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>setRenderTarget2</name>
            <comment>Sets the render target of the framebuffer to a texture. From here on, all rendering 
 is done into that texture instead of the actual framebuffer. The texture has to be 
 smaller or equal to the framebuffer, when FBO are not used/available. Rendering into 
 a texture can be slow on some hardware like Intel onboard chipsets. This is a special 
 purpose version of this method that allows to define a border that isn't affected by 
 the rendering. While possible, it's not recommended to blit into a render target.
 -
 texID - the ID of the texture to render into.
 left - the width of the left border
 top - the width of the upper border
 right - the width of the right border
 bottom - the width of the lower border
 clearAll - if true, the border won't affect the clearing of texture. If set to false, it will.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>texID</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>left</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>top</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>right</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>bottom</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>clearAll</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>clear</name>
            <comment>Clears the framebuffer and the z-buffer. If you are not doing this every frame, it 
 will lead to strange results on some devices...</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>sync</name>
            <comment>Synchronizes GPU and CPU and flushes the render pipeline.. 
 This isn't needed (and not even wanted) in most cases.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>removePostProcessor</name>
            <comment>Removes a post processor from the framebuffer. 
 The processor will be disposed and then removed.
 -
 proc - The post processor to be removed</comment>
            <returntype>void</returntype>
            <parameter>
                <name>proc</name>
                <type>com.threed.jpct.IPostProcessor</type>
            </parameter>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Creates a new framebuffer with a width of x and a height of y. The created
 buffer will be accessed by OpenGL ES 1.0/1.1. Make sure that your OpenGL context
 is 2.x before using this.
 -
 Width - the width of the framebuffer
 Height - the height of the framebuffer</comment>
            <returntype>void</returntype>
            <parameter>
                <name>Width</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>Height</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>Initialize1</name>
            <comment>Creates a new framebuffer with a width of x and a height of y. 
 This is for initializing the OpenGL ES2.0 pipeline. Make sure that your 
 OpenGL context is 1.0 before using this.
 -
 glContext - a valid gl context
 Width - the width of the framebuffer
 Height - the height of the framebuffer</comment>
            <returntype>void</returntype>
            <parameter>
                <name>glContext</name>
                <type>javax.microedition.khronos.opengles.GL10</type>
            </parameter>
            <parameter>
                <name>Width</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>Height</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>dispose</name>
            <comment>Should be called before this FrameBuffer won't be used anymore to do some clean up work. 
 For example, if you are reusing a buffer variable to assign a new FrameBuffer for it, 
 dispose the former one before doing so.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>getPixels2</name>
            <comment>Returns the raw pixel-data. This can be useful, if one wants to copy parts of the FrameBuffer 
 into an Image out of jPCT's focus. getPixels() should be called after calling update(), because 
 otherwise it is not guaranteed that the returned array contains the most current pixels. The
 returned array contains the pixel-data in RGB-format and with no alpha information. This method 
 is very slow, because it has to read all the pixels out of the VRAM and write them into the 
 FrameBuffer's internal pixel-buffer. This method takes an array to fill. The array has to have
 to proper size (i.e. framebuffer's height*width).
 -
 toFill - the array to fill</comment>
            <returntype>int[]</returntype>
            <parameter>
                <name>toFill</name>
                <type>int[]</type>
            </parameter>
        </method>
        <method>
            <name>OPAQUE_BLITTING</name>
            <comment>2D texture-blitting into the framebuffer is done by copying 
 the source 1-to-1 into the destination bitmap</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>freeMemory</name>
            <comment>Frees some native memory used by the gl context. Might be helpful to use this on a 
 framebuffer before the context is about to get lost, i.e. before the gl context becomes 
 invalid.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>display</name>
            <comment>Displays the rendered image.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>isInit</name>
            <comment>Checks if the FrameBuffer and the renderer have been initialized correctly.
 true, if the FrameBuffer is fine. Otherwise false.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>TRANSPARENT_BLITTING</name>
            <comment>2D texture-blitting into the framebuffer is done by copying 
 the source into the destination bitmap only at places where 
 the sources bitmap has none-zero color-values.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>removeAllPostProcessors</name>
            <comment>Removes all post processors from the framebuffer. 
 The processors will be disposed and then removed.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>setVirtualDimensions</name>
            <comment>This has a meaning only if a render target has been set. By default the fov calculations 
 will use the render target's dimensions. With this, you can set some other dimensions.
 -
 width - the virtual width of the render target
 height - the virtual height of the render target</comment>
            <returntype>void</returntype>
            <parameter>
                <name>width</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>height</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>flush</name>
            <comment>Flushes the render pipeline. This isn't needed 
 (and not even wanted) in most cases.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>clear2</name>
            <comment>Clears the framebuffer with the given color. If you are not doing this every frame, it will 
 lead to strange results on some devices...
 -
 col - the color the framebuffer is filled with</comment>
            <returntype>void</returntype>
            <parameter>
                <name>col</name>
                <type>com.threed.jpct.RGBColor</type>
            </parameter>
        </method>
        <method>
            <name>blit2</name>
            <comment>Special version of blit() that allows for scaling, i.e. it doesn't make 1-to-1 copies but can 
 up- or down-scale. In addition, it offers support for transparency, a different blending mode 
 and an additional color. If you want your blitted content to lay on top of the rendered image, 
 it has to be applied after calling update() on the buffer. This method is useful to copy 2D-GUI 
 elements into the rendered image (or for similar tasks). Blitting requires that the current world
 has been rendered at least once into the framebuffer where the blitting should be applied to 
 (for doing some intialization work). Usually, that shouldn't be a problem unless you are abusing 
 jPCT as a "blitting engine" only. There is no int[]-array-version of this method. Using this method 
 is quite to similar to using the Overlay-class. The difference is, that Overlay takes care of itself 
 and that it has a real depth.
 -
 src - the texture that contains the source bitmap
 srcX - the starting x-position in the source bitmap
 srcY - the starting y-position in the source bitmap
 destX - the starting x-position in the destination bitmap
 destY - the starting y-position in the destination bitmap
 sourceWidth - the width of the source region to copy
 sourceHeight - the height of the source region to copy
 destWidth - the width of the copied region in the destination bitmap
 destHeight - the height of the copied region in the destination bitmap
 transValue - the transparency, -1 is none, 0 is highest transparency. Higher values less transparency.
 additive - if true, the blending is additive, otherwise default
 addColor - an additional color. If null, Color.WHITE is taken instead</comment>
            <returntype>void</returntype>
            <parameter>
                <name>src</name>
                <type>com.threed.jpct.Texture</type>
            </parameter>
            <parameter>
                <name>srcX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>srcY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>destX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>destY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>sourceWidth</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>sourceHeight</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>destWidth</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>destHeight</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>transValue</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>additive</name>
                <type>boolean</type>
            </parameter>
            <parameter>
                <name>addColor</name>
                <type>com.threed.jpct.RGBColor</type>
            </parameter>
        </method>
        <method>
            <name>blit4</name>
            <comment>Copies a part of a bitmap (taken from an int[] containing pixels in RGB-format and with no alpha) 
 into the framebuffer. If you want your blitted content to lay on top of the rendered image, it has 
 to be applied after calling update() on the buffer. Can be combined with getPixels() to achieve 
 some special effects with the framebuffer. Blitting requires that the current world has been rendered 
 at least once into the framebuffer where the blitting should be applied to (for doing some 
 intialization work). Usually, that shouldn't be a problem unless you are abusing jPCT as a "blitting 
 engine" only. This method is very slow, because the int[] has to be converted and uploaded to the GPU 
 every time. To avoid this in some cases, Config.glUseIgnorantBlits can be set to true...but one should 
 be aware of the consequences. As a rule of thumb: If it's possible to avoid this method and use 
 a texture-based-blit instead...do it!
 -
 src - the int-array that contains the source bitmap
 srcWidth - the width of the source bitmap
 srcHeight - the height of the source bitmap
 srcX - the starting x-position in the source bitmap
 srcY - the starting y-position in the source bitmap
 destX - the starting x-position in the destination bitmap
 destY - the starting y-position in the destination bitmap
 width - the width of the region to copy
 height - the height of the region to copy
 transparent - black (or at least almost black) pixels won't be copied if this is set 
 to TRANSPARENT_BLITTING. Any color-value which leads to a result of zero when "anded" 
 with #f0f0f0 will be taken as black.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>src</name>
                <type>int[]</type>
            </parameter>
            <parameter>
                <name>srcWidth</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>srcHeight</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>srcX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>srcY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>destX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>destY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>width</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>height</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>transparent</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>blit3</name>
            <comment>Special version of blit() that allows for scaling, i.e. it doesn't make 1-to-1 copies but can 
 up- or down-scale. In addition, it offers support for transparency, a different blending mode 
 and an additional color. If you want your blitted content to lay on top of the rendered image, 
 it has to be applied after calling update() on the buffer. This method is useful to copy 2D-GUI 
 elements into the rendered image (or for similar tasks). Blitting requires that the current world 
 has been rendered at least once into the framebuffer where the blitting should be applied to 
 (for doing some intialization work). Usually, that shouldn't be a problem unless you are abusing 
 jPCT as a "blitting engine" only. There is no int[]-array-version of this method. Using this method 
 is quite to similar to using the Overlay-class. The difference is, that Overlay takes care of itself 
 and that it has a real depth.
 -
 src - the texture that contains the source bitmap
 srcX - the starting x-position in the source bitmap
 srcY - the starting y-position in the source bitmap
 destX - the starting x-position in the destination bitmap
 destY - the starting y-position in the destination bitmap
 sourceWidth - the width of the source region to copy
 sourceHeight - the height of the source region to copy
 destWidth - the width of the copied region in the destination bitmap
 destHeight - the height of the copied region in the destination bitmap
 transValue - the transparency, -1 is none, 0 is highest transparency. Higher values less transparency.
 additive - if true, the blending is additive, otherwise default</comment>
            <returntype>void</returntype>
            <parameter>
                <name>src</name>
                <type>com.threed.jpct.Texture</type>
            </parameter>
            <parameter>
                <name>srcX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>srcY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>destX</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>destY</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>sourceWidth</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>sourceHeight</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>destWidth</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>destHeight</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>transValue</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>additive</name>
                <type>boolean</type>
            </parameter>
        </method>
        <property>
            <name>RenderTarget1</name>
            <parameter>
                <name>texID</name>
                <type>int</type>
            </parameter>
            <comment>Sets the render target of the framebuffer to a texture. From here on, all rendering 
 is done into that texture instead of the actual framebuffer. The texture has to be 
 smaller or equal to the framebuffer. While possible, it's not recommended to blit 
 into a render target.
 -
 texID - the ID of the texture to render into.</comment>
        </property>
        <property>
            <name>CenterX</name>
            <returntype>float</returntype>
            <comment>Returns the x-coord of the midpoint of the framebuffer. This value represents the 
 internally used width/2.</comment>
        </property>
        <property>
            <name>OpenGLMajorVersion</name>
            <returntype>int</returntype>
            <comment>Returns the major version of OpenGL (1 or 2) that this FrameBuffer uses.</comment>
        </property>
        <property>
            <name>Pixels</name>
            <returntype>int[]</returntype>
            <comment>Returns the raw pixel-data. This can be useful, if one wants to copy parts of the FrameBuffer
 into an Image out of jPCT's focus. getPixels() should be called after calling update(), because 
 otherwise it is not guaranteed that the returned array contains the most current pixels. The 
 returned array contains the pixel-data in RGB-format and with no alpha information. This method 
 is very slow, because it has to read all the pixels out of the VRAM and write them into the 
 FrameBuffer's internal pixel-buffer.</comment>
        </property>
        <property>
            <name>CenterY</name>
            <returntype>float</returntype>
            <comment>Returns the y-coord of the midpoint of the framebuffer. This value represents the 
 internally used height/2.</comment>
        </property>
        <property>
            <name>RenderTarget3</name>
            <parameter>
                <name>tex</name>
                <type>com.threed.jpct.Texture</type>
            </parameter>
            <comment>Sets the render target of the framebuffer to a texture. From here on, all rendering
 is done into that texture instead of the actual framebuffer. The texture has to be 
 smaller or equal to the framebuffer. While possible, it's not recommended to blit 
 into a render target. If possible, use OpenGL ES 2.0 mode when using this, because 
 it's much more compatible.
 -
 tex - the texture to render into</comment>
        </property>
        <property>
            <name>ID</name>
            <returntype>java.lang.Long</returntype>
            <comment>Returns a unique ID for this FrameBuffer.</comment>
        </property>
        <property>
            <name>Height</name>
            <returntype>int</returntype>
            <comment>Returns the height of the framebuffer.</comment>
        </property>
        <property>
            <name>Width</name>
            <returntype>int</returntype>
            <comment>Returns the width of the framebuffer.</comment>
        </property>
        <property>
            <name>PaintListener</name>
            <parameter>
                <name>listener</name>
                <type>com.threed.jpct.IPaintListener</type>
            </parameter>
            <comment>Adds a listener to the renderer. The listener will be notified before the renderer starts 
 to paint polygons and after it has finished.
 -
 listener - IPaintListener the listener or null to clear it</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JDepthBuffer</name>
        <shortname>JpctDepthBuffer</shortname>
        <objectwrapper>com.threed.jpct.DepthBuffer</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Creates a new depth buffer.
 width - the width
 height - the height</comment>
            <returntype>void</returntype>
            <parameter>
                <name>width</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>height</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>Height</name>
            <returntype>int</returntype>
            <comment>Returns the height.</comment>
        </property>
        <property>
            <name>Width</name>
            <returntype>int</returntype>
            <comment>Returns the width.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JConfig</name>
        <shortname>JpctConfig</shortname>
        <objectwrapper>com.threed.jpct.Config</objectwrapper>
        <owner>process</owner>
        <method>
            <name>useVBO</name>
            <comment>Makes the engine use vertex buffer objects if possible instead of plain 
 vertex arrays.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>glTriangleStrips</name>
            <comment>Default is true.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>glDither</name>
            <comment>Use dithering.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>collideOffset</name>
            <comment>The maximum number in world units a polygon's corner and/or axis aligned 
 bounding box/octree-node (is used) may have from a position vector to be 
 taken into account as a potential collider in the collision detection 
 methods.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>collideEdgeMul</name>
            <comment>When using the sphere-polygon collision detection for the camera, it 
 may be useful to use a lower sphere radius for sphere-edge-collisions 
 to ensure that the camera slides around corners in a more realistic way.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>aggressiveStripping</name>
            <comment>A debug switch...might go away in later versions.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>oldStyle3DSLoader</name>
            <comment>jPCT 1.11+ features a fixed 3DS-loader, but the fix is based on experience,
 not on file format specs, because they were all different and inconsistent.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>collideSectorOffset</name>
            <comment>The number of units a position vector may be placed outside of a sector 
 and still be considered as part of it as far as collision detection is 
 concerned.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>maxAnimationSubSequences</name>
            <comment>The maximum number of sub-sequences an Animation may contain.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>maxPolysVisible</name>
            <comment>The maximum size of the VisList.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>disableNativeBufferCopies</name>
            <comment>Disables support for native buffer copies via libgdx even if it's 
 present in the classpath if set to true.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>renderTargetsAsSubImages</name>
            <comment>If true, render targets will be filled using a method to copy sub images.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>getParameterValue</name>
            <comment>Gets the current value of the parameter with the given name. Because if type of 
 the value is unknown, this method simply returns an Object. It's up to you to 
 convert it correctly.
 -
 name - the name</comment>
            <returntype>java.lang.Object</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>setParameterValue</name>
            <comment>Sets a parameter with the given name to a value. This method can be used to access 
 the configuration variables via their names instead of setting them directly. This 
 is more suitable for setting them from some configuration file's data, but its 
 slower than direct access, because it uses reflection.
 -
 name - the name
 value - the value</comment>
            <returntype>void</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>value</name>
                <type>java.lang.Object</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>flashSortThreshold</name>
            <comment>If the number of instances to sort exceeds this value, a flash sort will
 be used instead of the default quick sort.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>glBatchSize</name>
            <comment>When compiling an Object3D, the renderer has to assume an ideal batch 
 size for the underlying hardware.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>glUseIgnorantBlits</name>
            <comment>Forces the renderer to skip the texture conversion from the 
 FrameBuffer's blit(int[]...)</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>vectorCacheSize</name>
            <comment>Size of an internal cache for storing SimpleVectors.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>useRotationPivotFrom3DS</name>
            <comment>By default, jPCT-AE calculates a rotation pivot based on the mesh's 
 geometry when calling build().</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>glTrilinear</name>
            <comment>Use trilinear filtering between mip-map level.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>glTransparencyOffset</name>
            <comment>Modifies the offset for the transparency calculations in jPCT-AE.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>internalMipmapCreation</name>
            <comment>If true, jPCT-AE will always use its own mipmap generation code even 
 if the GPU or driver could do it on its own.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>glIgnoreNearPlane</name>
            <comment>If set to true, the renderer will ignore the configured near plane for 
 creating the frustum and use a default value instead.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>autoMaintainAspectRatio</name>
            <comment>Ensures that the aspect ratio doesn't change when changing framebuffer size.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>nearPlane</name>
            <comment>The near clipping plane.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>maxLights</name>
            <comment>The maximum number of lightsources that the Lights instance of a 
 World may handle.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>glTransparencyMul</name>
            <comment>Modifies the multiplicator for the transparency calculations in jPCT-AE.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>specPow</name>
            <comment>The sharpness of specular highlights.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>viewportOffsetY</name>
            <comment>Shifts the (normalized) viewport into y-direction, i.e. a value of 0.5 lets 
 the rendering start in the middle of the Framebuffer so that only the uppermost 
 half of the image is visible in the bottom of the framebuffer.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>farPlane</name>
            <comment>The far clipping plane.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>collideEllipsoidThreshold</name>
            <comment>A threshold that limits recursion for ellipsoid collision detection.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>specTerm</name>
            <comment>An "amplifier"-value for specular highlights.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>aaMode</name>
            <comment>Don't fiddle around with this!</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>glRevertADDtoMODULATE</name>
            <comment>When setting this to true, every texture blending operation that uses 
 the additive mode will be treated as if it were using modulation instead.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>useNormalsFromOBJ</name>
            <comment>By default, jPCT calculates normals based on the mesh's geometry 
 when calling build().</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>vertexBufferSize</name>
            <comment>Internal buffer used to upload vertex data to the gpu.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>glDebugLevel</name>
            <comment>Wraps gl calls to be printed out by the Logger if not set to 0.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>defaultCameraFOV</name>
            <comment>The default FOV for the camera.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>stateOrientedSorting</name>
            <comment>If true, sorting will be state oriented.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>glForceEnvMapToSecondStage</name>
            <comment>By default, an environment map will be applied to the first texture stage 
 if environment mapping is used on an object.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>polygonIDLimit</name>
            <comment>A value that defines how many polygon IDs that were part of a collision 
 will be stored before additional polygon IDs will be rejected.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>viewportOffsetX</name>
            <comment>the rendering start in the middle of the framebuffer so that only the leftmost
 half of the image is visible in the right half of the framebuffer.</comment>
            <returntype>float</returntype>
        </method>
        <method>
            <name>cacheCompressedTextures</name>
            <comment>Experimental!</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>maxTextureLayers</name>
            <comment>The maximum number of texture that a polygon can have.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>glForceHighPrecision</name>
            <comment>Forces high precision for shaders even if the shader source states otherwise.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>maxParentObjects</name>
            <comment>The maximum number of parent objects every object may have. usually,
 an object has only one parent object anyway.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>unloadImmediately</name>
            <comment>If true, textures will be unloaded immediately when calling one of 
 the unload-methods in the TextureManager.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>maxTextures</name>
            <comment>The inital number of textures the texture-manager can handle.</comment>
            <returntype>int</returntype>
        </method>
        <property>
            <name>ParameterNames</name>
            <returntype>java.lang.String[]</returntype>
            <comment>Returns the names of all public fields in Config, all configuration options.</comment>
        </property>
        <property>
            <name>Version</name>
            <returntype>java.lang.String</returntype>
            <comment>Returns the version of this release.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JCollisionListener</name>
        <shortname>JpctCollisionListener</shortname>
        <objectwrapper>jpct.ae.wrapper.CollisionListenerInterface</objectwrapper>
        <owner>process</owner>
        <event>CollisionListener(getAlgorithm As Int, getPolygonIDs() As Int, getType As Int, toString As String, getFirstContact As JpctSimpleVector, getObject As JpctObject3D, getSource As JpctObject3D, getTargets() As JpctObject3D)</event>
        <method>
            <name>Initialize</name>
            <comment>Initialize the Collision Listener
 eventName - the name of the Vertex Controller's event
 requiresPolygonIDs - return which polygons affected by collision?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>ba</name>
                <type>anywheresoftware.b4a.BA</type>
            </parameter>
            <parameter>
                <name>eventName</name>
                <type>java.lang.String</type>
            </parameter>
            <parameter>
                <name>requiresPolygonIDs</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>EVENT_ALGORITHM_RAY</name>
            <comment>The collision event was caused by a ray-polygon collision detection</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>EVENT_ALGORITHM_SPHERE</name>
            <comment>The collision event was caused by a sphere-polygon collision detection</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>EVENT_ALGORITHM_ELLIPSOID</name>
            <comment>The collision event was caused by a ellipsoid-polygon collision detection</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>EVENT_TYPE_SOURCE</name>
            <comment>The object is the source of the collision that has caused the event</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>EVENT_TYPE_TARGET</name>
            <comment>The object is a target of the collision that has caused the event</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JCamera</name>
        <shortname>JpctCamera</shortname>
        <objectwrapper>com.threed.jpct.Camera</objectwrapper>
        <owner>process</owner>
        <method>
            <name>rotateCameraZ</name>
            <comment>Rotates the camera around the z-axis. Unlike the rotateZ()-method inherited from 
 BufferedMatrix, this method takes care of the fact that rotating the camera using 
 an angle w actually means that the world rotates around -w.
 -
 angle - the angle</comment>
            <returntype>void</returntype>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>CAMERA_MOVEOUT</name>
            <comment>Move the camera backwards (relative to its current direction)</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>convertRADAngleIntoFOV</name>
            <comment>Converts an angle in radians into a FOV value that jPCT can handle (=2*tan(angle/2)).
 angle - the angle in radians</comment>
            <returntype>float</returntype>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>rotateCameraX</name>
            <comment>Rotates the camera around the x-axis. Unlike the rotateX()-method inherited from 
 BufferedMatrix, this method takes care of the fact that rotating the camera using 
 an angle w actually means that the world rotates around -w.
 -
 angle - the angle</comment>
            <returntype>void</returntype>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>CAMERA_MOVEIN</name>
            <comment>Move the camera forward (relative to its current direction)</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>rotateCameraY</name>
            <comment>Rotates the camera around the y-axis. Unlike the rotateAxisY()-method inherited from 
 BufferedMatrix, this method takes care of the fact that rotating the camera using an 
 angle w actually means that the world rotates around -w.
 -
 angle - the angle</comment>
            <returntype>void</returntype>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getProjectionMatrix</name>
            <comment>Returns the projection matrix.
 buffer - the framebuffer</comment>
            <returntype>com.threed.jpct.Matrix</returntype>
            <parameter>
                <name>buffer</name>
                <type>com.threed.jpct.FrameBuffer</type>
            </parameter>
        </method>
        <method>
            <name>rotateX</name>
            <comment>Rotates the camera around the x-axis.
 angle - the angle</comment>
            <returntype>void</returntype>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>decreaseFOV</name>
            <comment>Decreases the FOV. Useful for zoomout effects.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>dec</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>rotateZ</name>
            <comment>Rotates the camera around the z-axis.
 angle - the angle</comment>
            <returntype>void</returntype>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>rotateY</name>
            <comment>Rotates the camera around the y-axis.
 angle - the angle</comment>
            <returntype>void</returntype>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>increaseFOV</name>
            <comment>Increases the FOV. Useful for zoomin effects.</comment>
            <returntype>void</returntype>
            <parameter>
                <name>inc</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>convertDEGAngleIntoFOV</name>
            <comment>Converts an angle in degrees into a FOV value that jPCT can handle.
 angle - the angle in degrees</comment>
            <returntype>float</returntype>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>getDirection2</name>
            <comment>Returns the direction vector of the camera in world space and fills the 
 given SimpleVector with the result. The returned SimpleVector is already 
 normalized (it should always be normalized due to the nature of the 
 rotation matrix it comes from, but to avoid any possible rounding errors, 
 it's renormalized again within this method).
 -
 toFill - the vector that should contain the position</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>toFill</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>transform</name>
            <comment>Transforms a vertex from world into camera space.
 vertex - the vertex in world space</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>vertex</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>ELLIPSOID_TRANSFORMED</name>
            <comment>The camera's ellipsoid will be transformed when performing collision detection.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>CAMERA_MOVEUP</name>
            <comment>Move the camera up (relative to its current direction).</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>rotateCameraAxis</name>
            <comment>Rotates the camera around an arbitrary axis. The method is more powerful than the 
 normal rotate-around-an-axis methods, but also a bit slower. The resulting matrix 
 will be orthonormalized to ensure numerical accuracy. Unlike the rotateAxis()
 method inherited from BufferedMatrix, this method takes care of the fact that 
 rotating the camera using an angle w actually means that the world rotates around -w.
 -
 axis - a direction-vector pointing into the axis direction
 angle - the angle of the rotation</comment>
            <returntype>void</returntype>
            <parameter>
                <name>axis</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>DONT_SLIDE</name>
            <comment>Camera stops in front of obstacles.</comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>ELLIPSOID_ALIGNED</name>
            <comment>The camera's ellipsoid won't be transformed when performing collision detection (default).</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>setOrientation</name>
            <comment>Sets the orientation of the camera by giving a direction and an up-vector. 
 Make sure that these vectors are orthogonal.
 -
 dir - the direction
 up - the up-vector</comment>
            <returntype>void</returntype>
            <parameter>
                <name>dir</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>up</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>rotateAxis</name>
            <comment>Rotates the backbuffer matrix around an arbitrary axis. The method is more powerful 
 than the normal rotate-around-an-axis methods, but also a bit slower. The resulting 
 matrix will be orthonormalized to ensure numerical accuracy.
 -
 axis - a direction-vector pointing into the axis direction
 angle - the angle of the rotation</comment>
            <returntype>void</returntype>
            <parameter>
                <name>axis</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>angle</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>setFOVtoDefault</name>
            <comment>Resets the FOV to the default value configured in Config.</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <method>
            <name>Initialize</name>
            <comment>Initialize the Camera</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>CAMERA_MOVELEFT</name>
            <comment>Move the camera left (relative to its current direction)</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>CAMERA_DONT_MOVE</name>
            <comment>Don't move the camera before checking for a collision.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>setFOVLimits</name>
            <comment>Sets the limits for FOV jPCT should permit. Anything lower or higher will be 
 clipped to the lowest or highest possible value.
 -
 lower - the lowest possible FOV (default is 0.5)
 higher - the highest possible FOV (default is 1.5)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>lower</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>higher</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>moveCamera2</name>
            <comment>Moves (translates) the camera with a given speed in an arbitrary direction 
 (should be a normalized vector).
 -
 direction - the direction
 speed - the speed (positional change in units)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>direction</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <parameter>
                <name>speed</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>align</name>
            <comment>Aligns the camera with the (transformed) positive z-axis of an Object3D.
 This method works on the object's own rotation matrix only. It doesn't 
 take transformations of parent objects into account.
 -
 object - the object the camera should be aligned with</comment>
            <returntype>void</returntype>
            <parameter>
                <name>object</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
        </method>
        <method>
            <name>setPosition</name>
            <comment>Sets the camera to a position in worldspace. This method may be useful 
 if x, y and z are already discrete values. This method replaces the 
 deprecated setCamera()-method.
 -
 x,y,z - the components of the position vector</comment>
            <returntype>void</returntype>
            <parameter>
                <name>x</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>y</name>
                <type>float</type>
            </parameter>
            <parameter>
                <name>z</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>CAMERA_MOVEDOWN</name>
            <comment>Move the camera down (relative to its current direction)</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>getPosition2</name>
            <comment>Gets the current position of the camera and fills the given 
 SimpleVector with the result.
 -
 toFill - the vector that should contain the position</comment>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>toFill</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>lookAt</name>
            <comment>Rotates the camera so that is looks at the given position in world-space. 
 (it will only rotate, not move...).
 -
 lookAt - the position vector to look at</comment>
            <returntype>void</returntype>
            <parameter>
                <name>lookAt</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
        </method>
        <method>
            <name>CAMERA_MOVERIGHT</name>
            <comment>Move the camera right (relative to its current direction)</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>moveCamera</name>
            <comment>Moves (translates) the camera with a given speed into "mode" direction relative 
 to its current direction.
 -
 mode - the direction
 speed - the speed (positional change in units)</comment>
            <returntype>void</returntype>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>speed</name>
                <type>float</type>
            </parameter>
        </method>
        <method>
            <name>SLIDE</name>
            <comment>Camera slides along obstacles.</comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>YAxis</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the (virtual) y-axis of the camera.</comment>
        </property>
        <property>
            <name>UpVector</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the up vector of the camera in world space. The returned SimpleVector 
 is already normalized (it should always be normalized due to the nature of the 
 rotation matrix it comes from, but to avoid any possible rounding errors, it's 
 renormalized again within this method).</comment>
        </property>
        <property>
            <name>ZAxis</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the (virtual) z-axis of the camera.</comment>
        </property>
        <property>
            <name>XAxis</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the (virtual) x-axis of the camera.</comment>
        </property>
        <property>
            <name>SideVector</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the side vector of the camera in world space. The returned SimpleVector 
 is already normalized (it should always be normalized due to the nature of the 
 rotation matrix it comes from, but to avoid any possible rounding errors, it's 
 renormalized again within this method).</comment>
        </property>
        <property>
            <name>Direction</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <comment>Returns the direction vector of the camera in world space. The returned 
 SimpleVector is already normalized (it should always be normalized due 
 to the nature of the rotation matrix it comes from, but to avoid any 
 possible rounding errors, it's renormalized again within this method).</comment>
        </property>
        <property>
            <name>Back</name>
            <returntype>com.threed.jpct.Matrix</returntype>
            <parameter>
                <name>mat</name>
                <type>com.threed.jpct.Matrix</type>
            </parameter>
            <comment>Returns the Matrix that is used as the backbuffer matrix.</comment>
        </property>
        <property>
            <name>YFOV2</name>
            <parameter>
                <name>tanFOV</name>
                <type>float</type>
            </parameter>
            <comment>Sets the FOV in y-direction (within the limits set by setFOVLimits).
 tanFOV - the y-FOV (default is -1, which means that its derived from the x-FOV)</comment>
        </property>
        <property>
            <name>YFOV</name>
            <returntype>float</returntype>
            <comment>Returns the fov in y-direction. Default is -1, which means that the FOV-value in 
 y-direction will be calculated from the x-fov depending on the aspect-ratio-setting 
 in Config. Any other value will override this calculation with a fixed value.</comment>
        </property>
        <property>
            <name>PositionToCenter</name>
            <parameter>
                <name>object</name>
                <type>com.threed.jpct.Object3D</type>
            </parameter>
            <comment>Sets the camera to the position of the transformed center of an Object3D.
 object - the object</comment>
        </property>
        <property>
            <name>MinFOV</name>
            <returntype>float</returntype>
            <comment>Gets the lowest possible FOV.</comment>
        </property>
        <property>
            <name>FOV</name>
            <returntype>float</returntype>
            <parameter>
                <name>tanFOV</name>
                <type>float</type>
            </parameter>
            <comment>Returns the FOV.</comment>
        </property>
        <property>
            <name>EllipsoidMode</name>
            <returntype>int</returntype>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <comment>Returns the current ellipsoid mode.</comment>
        </property>
        <property>
            <name>Position</name>
            <returntype>com.threed.jpct.SimpleVector</returntype>
            <parameter>
                <name>pos</name>
                <type>com.threed.jpct.SimpleVector</type>
            </parameter>
            <comment>Gets the current position of the camera.</comment>
        </property>
        <property>
            <name>MaxFOV</name>
            <returntype>float</returntype>
            <comment>Gets the highest possible FOV.</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JBitmapHelper</name>
        <shortname>JpctBitmapHelper</shortname>
        <objectwrapper>com.threed.jpct.util.BitmapHelper</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Initialize BitmapHelper</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>rescale</name>
            <comment>Rescales a Bitmap.
 -
 bitmap - the bitmap
 width - the new width
 height - the new height</comment>
            <returntype>android.graphics.Bitmap</returntype>
            <parameter>
                <name>bitmap</name>
                <type>android.graphics.Bitmap</type>
            </parameter>
            <parameter>
                <name>width</name>
                <type>int</type>
            </parameter>
            <parameter>
                <name>height</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>loadImage</name>
            <comment>Creates a Bitmap from an Inputstream by using Android's BitmapFactory.
 if invalid InputStream passed, it will return null.
 is - the stream
Return type: @return:Bitmap or null</comment>
            <returntype>android.graphics.Bitmap</returntype>
            <parameter>
                <name>is</name>
                <type>java.io.InputStream</type>
            </parameter>
        </method>
        <method>
            <name>convert</name>
            <comment>Creates a Bitmap from a Drawable. This bypasses Android's BitmapFactory.
 However, Android is free to scale these resources on loading, so you might 
 have to rescale them to fit. Prefer to put your images for textures into 
 raw if possible.
 -
 drawable - the Drawable</comment>
            <returntype>android.graphics.Bitmap</returntype>
            <parameter>
                <name>drawable</name>
                <type>android.graphics.drawable.Drawable</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
    </class>
    <class>
        <name>jpct.ae.wrapper.JAnimation</name>
        <shortname>JpctAnimation</shortname>
        <objectwrapper>com.threed.jpct.Animation</objectwrapper>
        <owner>process</owner>
        <method>
            <name>USE_CLAMPING</name>
            <comment>Use clamping when the interpolation reaches the end of a sub-sequence.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>Initialize</name>
            <comment>Creates a new animation sequence that consist of keyframeCount keyframes
 -
 keyframeCount int</comment>
            <returntype>void</returntype>
            <parameter>
                <name>keyframeCount</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>createSubSequence</name>
            <comment>Creates a new sub-sequence. A sub-sequence is a part of the complete animation 
 that can be played stand-alone (like running, jumping etc.). Using the sub-sequence
 concept, it is possible to store all sub-animations for an object into one animation, 
 so that switching (and maybe interaction) between them is fast and comfortable. 
 Before adding the first keyframe you have to create a sub-sequence. The sub-sequence 
 will be numbered starting from 1. 0 is a special case as is represents the animation 
 as a whole.
 -
 name - the name of this sequence</comment>
            <returntype>int</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>getSequenceBorders</name>
            <comment>Gets the position of the start and the end frame of a sequence.
 -
 seq - a sequencean 
 Returns int[2]-array with the positions</comment>
            <returntype>int[]</returntype>
            <parameter>
                <name>seq</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>LINEAR</name>
            <comment>Use linear interpolation between keyframes.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>remove</name>
            <comment>Removes data of a sequence from an animation. The actual sequence is still there, 
 just without any data. Accessing it will cause a crash. This is useful to save 
 memory on animations that doesn't use all sequences.
 -
 seq - the sequence</comment>
            <returntype>void</returntype>
            <parameter>
                <name>seq</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>KEYFRAMESONLY</name>
            <comment>Use no interpolation between keyframes.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>addKeyFrame</name>
            <comment>Add a keyframe to a animation sequence. A keyframe is simply a mesh. A mesh can be
 obtained from an object by calling its getMesh()-method. Don't add a mesh as a keyframe
 that is already bound to an object that should use this animation, because this will
 result in the object to animate it's own mesh instead of the keyframes. If you want to
 use a mesh from such an object, don't add the mesh from getMesh() directly but make 
 a copy of it using cloneMesh(). It's a good way to generate meshes by getting them from
 temporary objects. Don't forget to calc the bounding box and the normals for these meshes
 (for example by calling build() for the temporary object). All the meshes of an animation
 have to have the same mesh-size (as well as the object that should use this animation).
 -
 keyFrame - the mesh of this keyframe</comment>
            <returntype>void</returntype>
            <parameter>
                <name>keyFrame</name>
                <type>com.threed.jpct.Mesh</type>
            </parameter>
        </method>
        <method>
            <name>strip</name>
            <comment>Removes triangle information from this animation's meshes. This is useful to save 
 some memory for meshes that are used for keyframing only (triangle information are 
 not needed in that case). For any other meshes: Don't call this method. It will 
 break your mesh!
 -
 usesCache boolean</comment>
            <returntype>void</returntype>
        </method>
        <method>
            <name>USE_WRAPPING</name>
            <comment>Use wrapping when the interpolation reaches the end of a sub-sequence.</comment>
            <returntype>int</returntype>
        </method>
        <method>
            <name>getName</name>
            <comment>Returns the name of a sequence.
 -
 seq - a sequence</comment>
            <returntype>java.lang.String</returntype>
            <parameter>
                <name>seq</name>
                <type>int</type>
            </parameter>
        </method>
        <method>
            <name>getSequence</name>
            <comment>Returns a sequence index for a given name. If non is found, -1 will be returned.
 -
 name - the sequence's name
 Returns the index or -1</comment>
            <returntype>int</returntype>
            <parameter>
                <name>name</name>
                <type>java.lang.String</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
        <property>
            <name>InterpolationMethod</name>
            <parameter>
                <name>method</name>
                <type>int</type>
            </parameter>
            <comment>Sets the method that should be used to interpolate vertices between keyframes.
 -
 method - the method</comment>
        </property>
        <property>
            <name>KeyFrames</name>
            <returntype>com.threed.jpct.Mesh[]</returntype>
            <comment>Returns the key frames of an animation as an array of Mesh.
 -
 the key frames</comment>
        </property>
        <property>
            <name>SequenceCount</name>
            <returntype>int</returntype>
            <comment>Returns the number of sequences used. Sequence 0 is implicit as it stands for the 
 animation as a whole. So a return value of 2 means, that you may play sub-sequence 
 1 or 2...or the whole animation using 0.</comment>
        </property>
        <property>
            <name>Caching</name>
            <parameter>
                <name>usesCache</name>
                <type>boolean</type>
            </parameter>
            <comment>If enabled, animations will be processed faster, you'll get a higher frame rate. 
 However, it consumes some more memory. Default is true.
 -
 usesCache boolean</comment>
        </property>
        <property>
            <name>ClampingMode</name>
            <parameter>
                <name>mode</name>
                <type>int</type>
            </parameter>
            <comment>Sets the clamping mode for animations.
 mode - the clamping mode</comment>
        </property>
    </class>
    <class>
        <name>jpct.ae.wrapper.JAAConfigChooser</name>
        <shortname>JpctAAConfigChooser</shortname>
        <objectwrapper>com.threed.jpct.util.AAConfigChooser</objectwrapper>
        <owner>process</owner>
        <method>
            <name>Initialize</name>
            <comment>Creates a new EGLConfigChooser that supports anti-aliasing.
 view - the JpctSurfaceView</comment>
            <returntype>void</returntype>
            <parameter>
                <name>view</name>
                <type>android.opengl.GLSurfaceView</type>
            </parameter>
        </method>
        <method>
            <name>Initialize2</name>
            <comment>Creates a new EGLConfigChooser that supports anti-aliasing with optional 
 alpha for the FrameBuffer.
 view - the JpctSurfaceView
 withAlpha - alpha channel (for transparent FrameBuffers)?</comment>
            <returntype>void</returntype>
            <parameter>
                <name>view</name>
                <type>android.opengl.GLSurfaceView</type>
            </parameter>
            <parameter>
                <name>withAlpha</name>
                <type>boolean</type>
            </parameter>
        </method>
        <method>
            <name>chooseConfig</name>
            <comment>chooseConfig
 - ?
 egl - 
 display -</comment>
            <returntype>javax.microedition.khronos.egl.EGLConfig</returntype>
            <parameter>
                <name>egl</name>
                <type>javax.microedition.khronos.egl.EGL10</type>
            </parameter>
            <parameter>
                <name>display</name>
                <type>javax.microedition.khronos.egl.EGLDisplay</type>
            </parameter>
        </method>
        <method>
            <name>IsInitialized</name>
            <comment></comment>
            <returntype>boolean</returntype>
        </method>
    </class>
    <version>1.0</version>
    <author>Alhowiriny</author>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
    <dependsOn>jpct_ae</dependsOn>
</root>
